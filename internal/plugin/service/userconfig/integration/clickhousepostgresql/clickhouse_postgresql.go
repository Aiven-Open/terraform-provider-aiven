// Code generated by user config generator. DO NOT EDIT.

package clickhousepostgresql

import (
	"context"

	setvalidator "github.com/hashicorp/terraform-plugin-framework-validators/setvalidator"
	attr "github.com/hashicorp/terraform-plugin-framework/attr"
	datasource "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	diag "github.com/hashicorp/terraform-plugin-framework/diag"
	resource "github.com/hashicorp/terraform-plugin-framework/resource/schema"
	stringdefault "github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	validator "github.com/hashicorp/terraform-plugin-framework/schema/validator"
	types "github.com/hashicorp/terraform-plugin-framework/types"

	schemautil "github.com/aiven/terraform-provider-aiven/internal/schemautil"
)

// NewResourceSchema returns resource schema
func NewResourceSchema() resource.SetNestedBlock {
	return resource.SetNestedBlock{
		Description: "ClickhousePostgresql user configurable settings",
		NestedObject: resource.NestedBlockObject{Blocks: map[string]resource.Block{"databases": resource.SetNestedBlock{
			Description: "Databases to expose",
			NestedObject: resource.NestedBlockObject{Attributes: map[string]resource.Attribute{
				"database": resource.StringAttribute{
					Computed:    true,
					Default:     stringdefault.StaticString("defaultdb"),
					Description: "PostgreSQL database to expose. The default value is `defaultdb`.",
					Optional:    true,
				},
				"schema": resource.StringAttribute{
					Computed:    true,
					Default:     stringdefault.StaticString("public"),
					Description: "PostgreSQL schema to expose. The default value is `public`.",
					Optional:    true,
				},
			}},
			Validators: []validator.Set{setvalidator.SizeAtMost(10)},
		}}},
		Validators: []validator.Set{setvalidator.SizeAtMost(1)},
	}
}

// NewDataSourceSchema returns datasource schema
func NewDataSourceSchema() datasource.SetNestedBlock {
	return datasource.SetNestedBlock{
		Description: "ClickhousePostgresql user configurable settings",
		NestedObject: datasource.NestedBlockObject{Blocks: map[string]datasource.Block{"databases": datasource.SetNestedBlock{
			Description: "Databases to expose",
			NestedObject: datasource.NestedBlockObject{Attributes: map[string]datasource.Attribute{
				"database": datasource.StringAttribute{
					Computed:    true,
					Description: "PostgreSQL database to expose. The default value is `defaultdb`.",
				},
				"schema": datasource.StringAttribute{
					Computed:    true,
					Description: "PostgreSQL schema to expose. The default value is `public`.",
				},
			}},
			Validators: []validator.Set{setvalidator.SizeAtMost(10)},
		}}},
		Validators: []validator.Set{setvalidator.SizeAtMost(1)},
	}
}

// tfoUserConfig ClickhousePostgresql user configurable settings
type tfoUserConfig struct {
	Databases types.Set `tfsdk:"databases"`
}

// dtoUserConfig request/response object
type dtoUserConfig struct {
	Databases []*dtoDatabases `groups:"create,update" json:"databases,omitempty"`
}

// expandUserConfig expands tf object into dto object
func expandUserConfig(ctx context.Context, diags diag.Diagnostics, o *tfoUserConfig) *dtoUserConfig {
	databasesVar := schemautil.ExpandSetNested(ctx, diags, expandDatabases, o.Databases)
	if diags.HasError() {
		return nil
	}
	return &dtoUserConfig{Databases: databasesVar}
}

// flattenUserConfig flattens dto object into tf object
func flattenUserConfig(ctx context.Context, diags diag.Diagnostics, o *dtoUserConfig) *tfoUserConfig {
	databasesVar := schemautil.FlattenSetNested(ctx, diags, flattenDatabases, o.Databases, databasesAttrs)
	if diags.HasError() {
		return nil
	}
	return &tfoUserConfig{Databases: databasesVar}
}

var userConfigAttrs = map[string]attr.Type{"databases": types.SetType{ElemType: types.ObjectType{AttrTypes: databasesAttrs}}}

// tfoDatabases Database to expose
type tfoDatabases struct {
	Database types.String `tfsdk:"database"`
	Schema   types.String `tfsdk:"schema"`
}

// dtoDatabases request/response object
type dtoDatabases struct {
	Database *string `groups:"create,update" json:"database,omitempty"`
	Schema   *string `groups:"create,update" json:"schema,omitempty"`
}

// expandDatabases expands tf object into dto object
func expandDatabases(ctx context.Context, diags diag.Diagnostics, o *tfoDatabases) *dtoDatabases {
	return &dtoDatabases{
		Database: schemautil.ValueStringPointer(o.Database),
		Schema:   schemautil.ValueStringPointer(o.Schema),
	}
}

// flattenDatabases flattens dto object into tf object
func flattenDatabases(ctx context.Context, diags diag.Diagnostics, o *dtoDatabases) *tfoDatabases {
	return &tfoDatabases{
		Database: types.StringPointerValue(o.Database),
		Schema:   types.StringPointerValue(o.Schema),
	}
}

var databasesAttrs = map[string]attr.Type{
	"database": types.StringType,
	"schema":   types.StringType,
}

// Expand public function that converts tf object into dto
func Expand(ctx context.Context, diags diag.Diagnostics, set types.Set) *dtoUserConfig {
	return schemautil.ExpandSetBlockNested[tfoUserConfig, dtoUserConfig](ctx, diags, expandUserConfig, set)
}

// Flatten public function that converts dto into tf object
func Flatten(ctx context.Context, diags diag.Diagnostics, m map[string]any) types.Set {
	o := new(dtoUserConfig)
	err := schemautil.MapToDTO(m, o)
	if err != nil {
		diags.AddError("Failed to marshal map user config to dto", err.Error())
		return types.SetNull(types.ObjectType{AttrTypes: userConfigAttrs})
	}
	return schemautil.FlattenSetBlockNested[dtoUserConfig, tfoUserConfig](ctx, diags, flattenUserConfig, o, userConfigAttrs)
}
