// Code generated by user config generator. DO NOT EDIT.

package logs

import (
	"context"

	setvalidator "github.com/hashicorp/terraform-plugin-framework-validators/setvalidator"
	attr "github.com/hashicorp/terraform-plugin-framework/attr"
	datasource "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	diag "github.com/hashicorp/terraform-plugin-framework/diag"
	resource "github.com/hashicorp/terraform-plugin-framework/resource/schema"
	int64default "github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
	stringdefault "github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	validator "github.com/hashicorp/terraform-plugin-framework/schema/validator"
	types "github.com/hashicorp/terraform-plugin-framework/types"

	schemautil "github.com/aiven/terraform-provider-aiven/internal/schemautil"
)

// NewResourceSchema returns resource schema
func NewResourceSchema() resource.SetNestedBlock {
	return resource.SetNestedBlock{
		Description: "Logs user configurable settings",
		NestedObject: resource.NestedBlockObject{Attributes: map[string]resource.Attribute{
			"elasticsearch_index_days_max": resource.Int64Attribute{
				Computed:    true,
				Default:     int64default.StaticInt64(3),
				Description: "Elasticsearch index retention limit. The default value is `3`.",
				Optional:    true,
			},
			"elasticsearch_index_prefix": resource.StringAttribute{
				Computed:    true,
				Default:     stringdefault.StaticString("logs"),
				Description: "Elasticsearch index prefix. The default value is `logs`.",
				Optional:    true,
			},
			"selected_log_fields": resource.SetAttribute{
				Computed:    true,
				Description: "The list of logging fields that will be sent to the integration logging service. The MESSAGE and timestamp fields are always sent.",
				ElementType: types.StringType,
				Optional:    true,
				Validators:  []validator.Set{setvalidator.SizeAtMost(5)},
			},
		}},
		Validators: []validator.Set{setvalidator.SizeAtMost(1)},
	}
}

// NewDataSourceSchema returns datasource schema
func NewDataSourceSchema() datasource.SetNestedBlock {
	return datasource.SetNestedBlock{
		Description: "Logs user configurable settings",
		NestedObject: datasource.NestedBlockObject{Attributes: map[string]datasource.Attribute{
			"elasticsearch_index_days_max": datasource.Int64Attribute{
				Computed:    true,
				Description: "Elasticsearch index retention limit. The default value is `3`.",
			},
			"elasticsearch_index_prefix": datasource.StringAttribute{
				Computed:    true,
				Description: "Elasticsearch index prefix. The default value is `logs`.",
			},
			"selected_log_fields": datasource.SetAttribute{
				Computed:    true,
				Description: "The list of logging fields that will be sent to the integration logging service. The MESSAGE and timestamp fields are always sent.",
				ElementType: types.StringType,
				Validators:  []validator.Set{setvalidator.SizeAtMost(5)},
			},
		}},
		Validators: []validator.Set{setvalidator.SizeAtMost(1)},
	}
}

// tfoUserConfig Logs user configurable settings
type tfoUserConfig struct {
	ElasticsearchIndexDaysMax types.Int64  `tfsdk:"elasticsearch_index_days_max"`
	ElasticsearchIndexPrefix  types.String `tfsdk:"elasticsearch_index_prefix"`
	SelectedLogFields         types.Set    `tfsdk:"selected_log_fields"`
}

// dtoUserConfig request/response object
type dtoUserConfig struct {
	ElasticsearchIndexDaysMax *int64   `groups:"create,update" json:"elasticsearch_index_days_max,omitempty"`
	ElasticsearchIndexPrefix  *string  `groups:"create,update" json:"elasticsearch_index_prefix,omitempty"`
	SelectedLogFields         []string `groups:"create,update" json:"selected_log_fields,omitempty"`
}

// expandUserConfig expands tf object into dto object
func expandUserConfig(ctx context.Context, diags diag.Diagnostics, o *tfoUserConfig) *dtoUserConfig {
	selectedLogFieldsVar := schemautil.ExpandSet[string](ctx, diags, o.SelectedLogFields)
	if diags.HasError() {
		return nil
	}
	return &dtoUserConfig{
		ElasticsearchIndexDaysMax: schemautil.ValueInt64Pointer(o.ElasticsearchIndexDaysMax),
		ElasticsearchIndexPrefix:  schemautil.ValueStringPointer(o.ElasticsearchIndexPrefix),
		SelectedLogFields:         selectedLogFieldsVar,
	}
}

// flattenUserConfig flattens dto object into tf object
func flattenUserConfig(ctx context.Context, diags diag.Diagnostics, o *dtoUserConfig) *tfoUserConfig {
	selectedLogFieldsVar, d := types.SetValueFrom(ctx, types.StringType, o.SelectedLogFields)
	diags.Append(d...)
	if diags.HasError() {
		return nil
	}
	return &tfoUserConfig{
		ElasticsearchIndexDaysMax: types.Int64PointerValue(o.ElasticsearchIndexDaysMax),
		ElasticsearchIndexPrefix:  types.StringPointerValue(o.ElasticsearchIndexPrefix),
		SelectedLogFields:         selectedLogFieldsVar,
	}
}

var userConfigAttrs = map[string]attr.Type{
	"elasticsearch_index_days_max": types.Int64Type,
	"elasticsearch_index_prefix":   types.StringType,
	"selected_log_fields":          types.SetType{ElemType: types.StringType},
}

// Expand public function that converts tf object into dto
func Expand(ctx context.Context, diags diag.Diagnostics, set types.Set) *dtoUserConfig {
	return schemautil.ExpandSetBlockNested[tfoUserConfig, dtoUserConfig](ctx, diags, expandUserConfig, set)
}

// Flatten public function that converts dto into tf object
func Flatten(ctx context.Context, diags diag.Diagnostics, m map[string]any) types.Set {
	o := new(dtoUserConfig)
	err := schemautil.MapToDTO(m, o)
	if err != nil {
		diags.AddError("Failed to marshal map user config to dto", err.Error())
		return types.SetNull(types.ObjectType{AttrTypes: userConfigAttrs})
	}
	return schemautil.FlattenSetBlockNested[dtoUserConfig, tfoUserConfig](ctx, diags, flattenUserConfig, o, userConfigAttrs)
}
