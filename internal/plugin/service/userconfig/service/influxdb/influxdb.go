// Code generated by user config generator. DO NOT EDIT.

package influxdb

import (
	"context"
	"encoding/json"

	setvalidator "github.com/hashicorp/terraform-plugin-framework-validators/setvalidator"
	attr "github.com/hashicorp/terraform-plugin-framework/attr"
	datasource "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	diag "github.com/hashicorp/terraform-plugin-framework/diag"
	resource "github.com/hashicorp/terraform-plugin-framework/resource/schema"
	validator "github.com/hashicorp/terraform-plugin-framework/schema/validator"
	types "github.com/hashicorp/terraform-plugin-framework/types"

	schemautil "github.com/aiven/terraform-provider-aiven/internal/schemautil"
)

// NewResourceSchema returns resource schema
func NewResourceSchema() resource.SetNestedBlock {
	return resource.SetNestedBlock{
		Description: "Influxdb user configurable settings",
		NestedObject: resource.NestedBlockObject{
			Attributes: map[string]resource.Attribute{
				"additional_backup_regions": resource.SetAttribute{
					Computed:    true,
					Description: "Additional Cloud Regions for Backup Replication.",
					ElementType: types.StringType,
					Optional:    true,
					Validators:  []validator.Set{setvalidator.SizeAtMost(1)},
				},
				"custom_domain": resource.StringAttribute{
					Computed:    true,
					Description: "Serve the web frontend using a custom CNAME pointing to the Aiven DNS name.",
					Optional:    true,
				},
				"project_to_fork_from": resource.StringAttribute{
					Computed:    true,
					Description: "Name of another project to fork a service from. This has effect only when a new service is being created.",
					Optional:    true,
				},
				"recovery_basebackup_name": resource.StringAttribute{
					Computed:    true,
					Description: "Name of the basebackup to restore in forked service.",
					Optional:    true,
				},
				"service_to_fork_from": resource.StringAttribute{
					Computed:    true,
					Description: "Name of another service to fork from. This has effect only when a new service is being created.",
					Optional:    true,
				},
				"static_ips": resource.BoolAttribute{
					Computed:    true,
					Description: "Use static public IP addresses.",
					Optional:    true,
				},
			},
			Blocks: map[string]resource.Block{
				"influxdb": resource.SetNestedBlock{
					Description: "influxdb.conf configuration values",
					NestedObject: resource.NestedBlockObject{Attributes: map[string]resource.Attribute{
						"log_queries_after": resource.Int64Attribute{
							Computed:    true,
							Description: "The maximum duration in seconds before a query is logged as a slow query. Setting this to 0 (the default) will never log slow queries.",
							Optional:    true,
						},
						"max_connection_limit": resource.Int64Attribute{
							Computed:    true,
							Description: "Maximum number of connections to InfluxDB. Setting this to 0 (default) means no limit. If using max_connection_limit, it is recommended to set the value to be large enough in order to not block clients unnecessarily.",
							Optional:    true,
						},
						"max_row_limit": resource.Int64Attribute{
							Computed:    true,
							Description: "The maximum number of rows returned in a non-chunked query. Setting this to 0 (the default) allows an unlimited number to be returned.",
							Optional:    true,
						},
						"max_select_buckets": resource.Int64Attribute{
							Computed:    true,
							Description: "The maximum number of `GROUP BY time()` buckets that can be processed in a query. Setting this to 0 (the default) allows an unlimited number to be processed.",
							Optional:    true,
						},
						"max_select_point": resource.Int64Attribute{
							Computed:    true,
							Description: "The maximum number of points that can be processed in a SELECT statement. Setting this to 0 (the default) allows an unlimited number to be processed.",
							Optional:    true,
						},
						"query_log_enabled": resource.BoolAttribute{
							Computed:    true,
							Description: "Whether queries should be logged before execution. May log sensitive data contained within a query.",
							Optional:    true,
						},
						"query_timeout": resource.Int64Attribute{
							Computed:    true,
							Description: "The maximum duration in seconds before a query is killed. Setting this to 0 (the default) will never kill slow queries.",
							Optional:    true,
						},
					}},
				},
				"ip_filter": resource.SetNestedBlock{
					Description: "Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'",
					NestedObject: resource.NestedBlockObject{Attributes: map[string]resource.Attribute{
						"description": resource.StringAttribute{
							Computed:    true,
							Description: "Description for IP filter list entry.",
							Optional:    true,
						},
						"network": resource.StringAttribute{
							Description: "CIDR address block.",
							Required:    true,
						},
					}},
					Validators: []validator.Set{setvalidator.SizeAtMost(1024)},
				},
				"private_access": resource.SetNestedBlock{
					Description: "Allow access to selected service ports from private networks",
					NestedObject: resource.NestedBlockObject{Attributes: map[string]resource.Attribute{"influxdb": resource.BoolAttribute{
						Computed:    true,
						Description: "Allow clients to connect to influxdb with a DNS name that always resolves to the service's private IP addresses. Only available in certain network locations.",
						Optional:    true,
					}}},
				},
				"privatelink_access": resource.SetNestedBlock{
					Description: "Allow access to selected service components through Privatelink",
					NestedObject: resource.NestedBlockObject{Attributes: map[string]resource.Attribute{"influxdb": resource.BoolAttribute{
						Computed:    true,
						Description: "Enable influxdb.",
						Optional:    true,
					}}},
				},
				"public_access": resource.SetNestedBlock{
					Description: "Allow access to selected service ports from the public Internet",
					NestedObject: resource.NestedBlockObject{Attributes: map[string]resource.Attribute{"influxdb": resource.BoolAttribute{
						Computed:    true,
						Description: "Allow clients to connect to influxdb from the public internet for service nodes that are in a project VPC or another type of private network.",
						Optional:    true,
					}}},
				},
			},
		},
		Validators: []validator.Set{setvalidator.SizeAtMost(1)},
	}
}

// NewDataSourceSchema returns datasource schema
func NewDataSourceSchema() datasource.SetNestedBlock {
	return datasource.SetNestedBlock{
		Description: "Influxdb user configurable settings",
		NestedObject: datasource.NestedBlockObject{
			Attributes: map[string]datasource.Attribute{
				"additional_backup_regions": datasource.SetAttribute{
					Computed:    true,
					Description: "Additional Cloud Regions for Backup Replication.",
					ElementType: types.StringType,
					Validators:  []validator.Set{setvalidator.SizeAtMost(1)},
				},
				"custom_domain": datasource.StringAttribute{
					Computed:    true,
					Description: "Serve the web frontend using a custom CNAME pointing to the Aiven DNS name.",
				},
				"project_to_fork_from": datasource.StringAttribute{
					Computed:    true,
					Description: "Name of another project to fork a service from. This has effect only when a new service is being created.",
				},
				"recovery_basebackup_name": datasource.StringAttribute{
					Computed:    true,
					Description: "Name of the basebackup to restore in forked service.",
				},
				"service_to_fork_from": datasource.StringAttribute{
					Computed:    true,
					Description: "Name of another service to fork from. This has effect only when a new service is being created.",
				},
				"static_ips": datasource.BoolAttribute{
					Computed:    true,
					Description: "Use static public IP addresses.",
				},
			},
			Blocks: map[string]datasource.Block{
				"influxdb": datasource.SetNestedBlock{
					Description: "influxdb.conf configuration values",
					NestedObject: datasource.NestedBlockObject{Attributes: map[string]datasource.Attribute{
						"log_queries_after": datasource.Int64Attribute{
							Computed:    true,
							Description: "The maximum duration in seconds before a query is logged as a slow query. Setting this to 0 (the default) will never log slow queries.",
						},
						"max_connection_limit": datasource.Int64Attribute{
							Computed:    true,
							Description: "Maximum number of connections to InfluxDB. Setting this to 0 (default) means no limit. If using max_connection_limit, it is recommended to set the value to be large enough in order to not block clients unnecessarily.",
						},
						"max_row_limit": datasource.Int64Attribute{
							Computed:    true,
							Description: "The maximum number of rows returned in a non-chunked query. Setting this to 0 (the default) allows an unlimited number to be returned.",
						},
						"max_select_buckets": datasource.Int64Attribute{
							Computed:    true,
							Description: "The maximum number of `GROUP BY time()` buckets that can be processed in a query. Setting this to 0 (the default) allows an unlimited number to be processed.",
						},
						"max_select_point": datasource.Int64Attribute{
							Computed:    true,
							Description: "The maximum number of points that can be processed in a SELECT statement. Setting this to 0 (the default) allows an unlimited number to be processed.",
						},
						"query_log_enabled": datasource.BoolAttribute{
							Computed:    true,
							Description: "Whether queries should be logged before execution. May log sensitive data contained within a query.",
						},
						"query_timeout": datasource.Int64Attribute{
							Computed:    true,
							Description: "The maximum duration in seconds before a query is killed. Setting this to 0 (the default) will never kill slow queries.",
						},
					}},
				},
				"ip_filter": datasource.SetNestedBlock{
					Description: "Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'",
					NestedObject: datasource.NestedBlockObject{Attributes: map[string]datasource.Attribute{
						"description": datasource.StringAttribute{
							Computed:    true,
							Description: "Description for IP filter list entry.",
						},
						"network": datasource.StringAttribute{
							Computed:    true,
							Description: "CIDR address block.",
						},
					}},
					Validators: []validator.Set{setvalidator.SizeAtMost(1024)},
				},
				"private_access": datasource.SetNestedBlock{
					Description: "Allow access to selected service ports from private networks",
					NestedObject: datasource.NestedBlockObject{Attributes: map[string]datasource.Attribute{"influxdb": datasource.BoolAttribute{
						Computed:    true,
						Description: "Allow clients to connect to influxdb with a DNS name that always resolves to the service's private IP addresses. Only available in certain network locations.",
					}}},
				},
				"privatelink_access": datasource.SetNestedBlock{
					Description: "Allow access to selected service components through Privatelink",
					NestedObject: datasource.NestedBlockObject{Attributes: map[string]datasource.Attribute{"influxdb": datasource.BoolAttribute{
						Computed:    true,
						Description: "Enable influxdb.",
					}}},
				},
				"public_access": datasource.SetNestedBlock{
					Description: "Allow access to selected service ports from the public Internet",
					NestedObject: datasource.NestedBlockObject{Attributes: map[string]datasource.Attribute{"influxdb": datasource.BoolAttribute{
						Computed:    true,
						Description: "Allow clients to connect to influxdb from the public internet for service nodes that are in a project VPC or another type of private network.",
					}}},
				},
			},
		},
		Validators: []validator.Set{setvalidator.SizeAtMost(1)},
	}
}

// tfoUserConfig Influxdb user configurable settings
type tfoUserConfig struct {
	AdditionalBackupRegions types.Set    `tfsdk:"additional_backup_regions"`
	CustomDomain            types.String `tfsdk:"custom_domain"`
	Influxdb                types.Set    `tfsdk:"influxdb"`
	IpFilter                types.Set    `tfsdk:"ip_filter"`
	PrivateAccess           types.Set    `tfsdk:"private_access"`
	PrivatelinkAccess       types.Set    `tfsdk:"privatelink_access"`
	ProjectToForkFrom       types.String `tfsdk:"project_to_fork_from"`
	PublicAccess            types.Set    `tfsdk:"public_access"`
	RecoveryBasebackupName  types.String `tfsdk:"recovery_basebackup_name"`
	ServiceToForkFrom       types.String `tfsdk:"service_to_fork_from"`
	StaticIps               types.Bool   `tfsdk:"static_ips"`
}

// dtoUserConfig request/response object
type dtoUserConfig struct {
	AdditionalBackupRegions []string              `groups:"create,update" json:"additional_backup_regions,omitempty"`
	CustomDomain            *string               `groups:"create,update" json:"custom_domain,omitempty"`
	Influxdb                *dtoInfluxdb          `groups:"create,update" json:"influxdb,omitempty"`
	IpFilter                []*dtoIpFilter        `groups:"create,update" json:"ip_filter,omitempty"`
	PrivateAccess           *dtoPrivateAccess     `groups:"create,update" json:"private_access,omitempty"`
	PrivatelinkAccess       *dtoPrivatelinkAccess `groups:"create,update" json:"privatelink_access,omitempty"`
	ProjectToForkFrom       *string               `groups:"create" json:"project_to_fork_from,omitempty"`
	PublicAccess            *dtoPublicAccess      `groups:"create,update" json:"public_access,omitempty"`
	RecoveryBasebackupName  *string               `groups:"create,update" json:"recovery_basebackup_name,omitempty"`
	ServiceToForkFrom       *string               `groups:"create" json:"service_to_fork_from,omitempty"`
	StaticIps               *bool                 `groups:"create,update" json:"static_ips,omitempty"`
}

// expandUserConfig expands tf object into dto object
func expandUserConfig(ctx context.Context, diags diag.Diagnostics, o *tfoUserConfig) *dtoUserConfig {
	additionalBackupRegionsVar := schemautil.ExpandSet[string](ctx, diags, o.AdditionalBackupRegions)
	if diags.HasError() {
		return nil
	}
	influxdbVar := schemautil.ExpandSetBlockNested(ctx, diags, expandInfluxdb, o.Influxdb)
	if diags.HasError() {
		return nil
	}
	ipFilterVar := schemautil.ExpandSetNested(ctx, diags, expandIpFilter, o.IpFilter)
	if diags.HasError() {
		return nil
	}
	privateAccessVar := schemautil.ExpandSetBlockNested(ctx, diags, expandPrivateAccess, o.PrivateAccess)
	if diags.HasError() {
		return nil
	}
	privatelinkAccessVar := schemautil.ExpandSetBlockNested(ctx, diags, expandPrivatelinkAccess, o.PrivatelinkAccess)
	if diags.HasError() {
		return nil
	}
	publicAccessVar := schemautil.ExpandSetBlockNested(ctx, diags, expandPublicAccess, o.PublicAccess)
	if diags.HasError() {
		return nil
	}
	return &dtoUserConfig{
		AdditionalBackupRegions: additionalBackupRegionsVar,
		CustomDomain:            schemautil.ValueStringPointer(o.CustomDomain),
		Influxdb:                influxdbVar,
		IpFilter:                ipFilterVar,
		PrivateAccess:           privateAccessVar,
		PrivatelinkAccess:       privatelinkAccessVar,
		ProjectToForkFrom:       schemautil.ValueStringPointer(o.ProjectToForkFrom),
		PublicAccess:            publicAccessVar,
		RecoveryBasebackupName:  schemautil.ValueStringPointer(o.RecoveryBasebackupName),
		ServiceToForkFrom:       schemautil.ValueStringPointer(o.ServiceToForkFrom),
		StaticIps:               schemautil.ValueBoolPointer(o.StaticIps),
	}
}

// flattenUserConfig flattens dto object into tf object
func flattenUserConfig(ctx context.Context, diags diag.Diagnostics, o *dtoUserConfig) *tfoUserConfig {
	additionalBackupRegionsVar, d := types.SetValueFrom(ctx, types.StringType, o.AdditionalBackupRegions)
	diags.Append(d...)
	if diags.HasError() {
		return nil
	}
	influxdbVar := schemautil.FlattenSetBlockNested(ctx, diags, flattenInfluxdb, o.Influxdb, influxdbAttrs)
	if diags.HasError() {
		return nil
	}
	ipFilterVar := schemautil.FlattenSetNested(ctx, diags, flattenIpFilter, o.IpFilter, ipFilterAttrs)
	if diags.HasError() {
		return nil
	}
	privateAccessVar := schemautil.FlattenSetBlockNested(ctx, diags, flattenPrivateAccess, o.PrivateAccess, privateAccessAttrs)
	if diags.HasError() {
		return nil
	}
	privatelinkAccessVar := schemautil.FlattenSetBlockNested(ctx, diags, flattenPrivatelinkAccess, o.PrivatelinkAccess, privatelinkAccessAttrs)
	if diags.HasError() {
		return nil
	}
	publicAccessVar := schemautil.FlattenSetBlockNested(ctx, diags, flattenPublicAccess, o.PublicAccess, publicAccessAttrs)
	if diags.HasError() {
		return nil
	}
	return &tfoUserConfig{
		AdditionalBackupRegions: additionalBackupRegionsVar,
		CustomDomain:            types.StringPointerValue(o.CustomDomain),
		Influxdb:                influxdbVar,
		IpFilter:                ipFilterVar,
		PrivateAccess:           privateAccessVar,
		PrivatelinkAccess:       privatelinkAccessVar,
		ProjectToForkFrom:       types.StringPointerValue(o.ProjectToForkFrom),
		PublicAccess:            publicAccessVar,
		RecoveryBasebackupName:  types.StringPointerValue(o.RecoveryBasebackupName),
		ServiceToForkFrom:       types.StringPointerValue(o.ServiceToForkFrom),
		StaticIps:               types.BoolPointerValue(o.StaticIps),
	}
}

var userConfigAttrs = map[string]attr.Type{
	"additional_backup_regions": types.SetType{ElemType: types.StringType},
	"custom_domain":             types.StringType,
	"influxdb":                  types.SetType{ElemType: types.ObjectType{AttrTypes: influxdbAttrs}},
	"ip_filter":                 types.SetType{ElemType: types.ObjectType{AttrTypes: ipFilterAttrs}},
	"private_access":            types.SetType{ElemType: types.ObjectType{AttrTypes: privateAccessAttrs}},
	"privatelink_access":        types.SetType{ElemType: types.ObjectType{AttrTypes: privatelinkAccessAttrs}},
	"project_to_fork_from":      types.StringType,
	"public_access":             types.SetType{ElemType: types.ObjectType{AttrTypes: publicAccessAttrs}},
	"recovery_basebackup_name":  types.StringType,
	"service_to_fork_from":      types.StringType,
	"static_ips":                types.BoolType,
}

// tfoInfluxdb influxdb.conf configuration values
type tfoInfluxdb struct {
	LogQueriesAfter    types.Int64 `tfsdk:"log_queries_after"`
	MaxConnectionLimit types.Int64 `tfsdk:"max_connection_limit"`
	MaxRowLimit        types.Int64 `tfsdk:"max_row_limit"`
	MaxSelectBuckets   types.Int64 `tfsdk:"max_select_buckets"`
	MaxSelectPoint     types.Int64 `tfsdk:"max_select_point"`
	QueryLogEnabled    types.Bool  `tfsdk:"query_log_enabled"`
	QueryTimeout       types.Int64 `tfsdk:"query_timeout"`
}

// dtoInfluxdb request/response object
type dtoInfluxdb struct {
	LogQueriesAfter    *int64 `groups:"create,update" json:"log_queries_after,omitempty"`
	MaxConnectionLimit *int64 `groups:"create,update" json:"max_connection_limit,omitempty"`
	MaxRowLimit        *int64 `groups:"create,update" json:"max_row_limit,omitempty"`
	MaxSelectBuckets   *int64 `groups:"create,update" json:"max_select_buckets,omitempty"`
	MaxSelectPoint     *int64 `groups:"create,update" json:"max_select_point,omitempty"`
	QueryLogEnabled    *bool  `groups:"create,update" json:"query_log_enabled,omitempty"`
	QueryTimeout       *int64 `groups:"create,update" json:"query_timeout,omitempty"`
}

// expandInfluxdb expands tf object into dto object
func expandInfluxdb(ctx context.Context, diags diag.Diagnostics, o *tfoInfluxdb) *dtoInfluxdb {
	return &dtoInfluxdb{
		LogQueriesAfter:    schemautil.ValueInt64Pointer(o.LogQueriesAfter),
		MaxConnectionLimit: schemautil.ValueInt64Pointer(o.MaxConnectionLimit),
		MaxRowLimit:        schemautil.ValueInt64Pointer(o.MaxRowLimit),
		MaxSelectBuckets:   schemautil.ValueInt64Pointer(o.MaxSelectBuckets),
		MaxSelectPoint:     schemautil.ValueInt64Pointer(o.MaxSelectPoint),
		QueryLogEnabled:    schemautil.ValueBoolPointer(o.QueryLogEnabled),
		QueryTimeout:       schemautil.ValueInt64Pointer(o.QueryTimeout),
	}
}

// flattenInfluxdb flattens dto object into tf object
func flattenInfluxdb(ctx context.Context, diags diag.Diagnostics, o *dtoInfluxdb) *tfoInfluxdb {
	return &tfoInfluxdb{
		LogQueriesAfter:    types.Int64PointerValue(o.LogQueriesAfter),
		MaxConnectionLimit: types.Int64PointerValue(o.MaxConnectionLimit),
		MaxRowLimit:        types.Int64PointerValue(o.MaxRowLimit),
		MaxSelectBuckets:   types.Int64PointerValue(o.MaxSelectBuckets),
		MaxSelectPoint:     types.Int64PointerValue(o.MaxSelectPoint),
		QueryLogEnabled:    types.BoolPointerValue(o.QueryLogEnabled),
		QueryTimeout:       types.Int64PointerValue(o.QueryTimeout),
	}
}

var influxdbAttrs = map[string]attr.Type{
	"log_queries_after":    types.Int64Type,
	"max_connection_limit": types.Int64Type,
	"max_row_limit":        types.Int64Type,
	"max_select_buckets":   types.Int64Type,
	"max_select_point":     types.Int64Type,
	"query_log_enabled":    types.BoolType,
	"query_timeout":        types.Int64Type,
}

// tfoIpFilter CIDR address block, either as a string, or in a dict with an optional description field
type tfoIpFilter struct {
	Description types.String `tfsdk:"description"`
	Network     types.String `tfsdk:"network"`
}

// dtoIpFilter request/response object
type dtoIpFilter struct {
	Description *string `groups:"create,update" json:"description,omitempty"`
	Network     string  `groups:"create,update" json:"network"`
}

func (d *dtoIpFilter) UnmarshalJSON(data []byte) error {
	var s string
	err := json.Unmarshal(data, &s)
	if err == nil {
		d.Network = s
		return nil
	}

	type obj dtoIpFilter
	o := &struct {
		Description *string `groups:"create,update" json:"description,omitempty"`
		Network     string  `groups:"create,update" json:"network"`
	}{}
	err = json.Unmarshal(data, o)
	if err != nil {
		return err
	}

	d.Description = o.Description
	d.Network = o.Network
	return nil
}

// expandIpFilter expands tf object into dto object
func expandIpFilter(ctx context.Context, diags diag.Diagnostics, o *tfoIpFilter) *dtoIpFilter {
	return &dtoIpFilter{
		Description: schemautil.ValueStringPointer(o.Description),
		Network:     o.Network.ValueString(),
	}
}

// flattenIpFilter flattens dto object into tf object
func flattenIpFilter(ctx context.Context, diags diag.Diagnostics, o *dtoIpFilter) *tfoIpFilter {
	return &tfoIpFilter{
		Description: types.StringPointerValue(o.Description),
		Network:     types.StringValue(o.Network),
	}
}

var ipFilterAttrs = map[string]attr.Type{
	"description": types.StringType,
	"network":     types.StringType,
}

// tfoPrivateAccess Allow access to selected service ports from private networks
type tfoPrivateAccess struct {
	Influxdb types.Bool `tfsdk:"influxdb"`
}

// dtoPrivateAccess request/response object
type dtoPrivateAccess struct {
	Influxdb *bool `groups:"create,update" json:"influxdb,omitempty"`
}

// expandPrivateAccess expands tf object into dto object
func expandPrivateAccess(ctx context.Context, diags diag.Diagnostics, o *tfoPrivateAccess) *dtoPrivateAccess {
	return &dtoPrivateAccess{Influxdb: schemautil.ValueBoolPointer(o.Influxdb)}
}

// flattenPrivateAccess flattens dto object into tf object
func flattenPrivateAccess(ctx context.Context, diags diag.Diagnostics, o *dtoPrivateAccess) *tfoPrivateAccess {
	return &tfoPrivateAccess{Influxdb: types.BoolPointerValue(o.Influxdb)}
}

var privateAccessAttrs = map[string]attr.Type{"influxdb": types.BoolType}

// tfoPrivatelinkAccess Allow access to selected service components through Privatelink
type tfoPrivatelinkAccess struct {
	Influxdb types.Bool `tfsdk:"influxdb"`
}

// dtoPrivatelinkAccess request/response object
type dtoPrivatelinkAccess struct {
	Influxdb *bool `groups:"create,update" json:"influxdb,omitempty"`
}

// expandPrivatelinkAccess expands tf object into dto object
func expandPrivatelinkAccess(ctx context.Context, diags diag.Diagnostics, o *tfoPrivatelinkAccess) *dtoPrivatelinkAccess {
	return &dtoPrivatelinkAccess{Influxdb: schemautil.ValueBoolPointer(o.Influxdb)}
}

// flattenPrivatelinkAccess flattens dto object into tf object
func flattenPrivatelinkAccess(ctx context.Context, diags diag.Diagnostics, o *dtoPrivatelinkAccess) *tfoPrivatelinkAccess {
	return &tfoPrivatelinkAccess{Influxdb: types.BoolPointerValue(o.Influxdb)}
}

var privatelinkAccessAttrs = map[string]attr.Type{"influxdb": types.BoolType}

// tfoPublicAccess Allow access to selected service ports from the public Internet
type tfoPublicAccess struct {
	Influxdb types.Bool `tfsdk:"influxdb"`
}

// dtoPublicAccess request/response object
type dtoPublicAccess struct {
	Influxdb *bool `groups:"create,update" json:"influxdb,omitempty"`
}

// expandPublicAccess expands tf object into dto object
func expandPublicAccess(ctx context.Context, diags diag.Diagnostics, o *tfoPublicAccess) *dtoPublicAccess {
	return &dtoPublicAccess{Influxdb: schemautil.ValueBoolPointer(o.Influxdb)}
}

// flattenPublicAccess flattens dto object into tf object
func flattenPublicAccess(ctx context.Context, diags diag.Diagnostics, o *dtoPublicAccess) *tfoPublicAccess {
	return &tfoPublicAccess{Influxdb: types.BoolPointerValue(o.Influxdb)}
}

var publicAccessAttrs = map[string]attr.Type{"influxdb": types.BoolType}

// Expand public function that converts tf object into dto
func Expand(ctx context.Context, diags diag.Diagnostics, set types.Set) *dtoUserConfig {
	return schemautil.ExpandSetBlockNested[tfoUserConfig, dtoUserConfig](ctx, diags, expandUserConfig, set)
}

// Flatten public function that converts dto into tf object
func Flatten(ctx context.Context, diags diag.Diagnostics, m map[string]any) types.Set {
	o := new(dtoUserConfig)
	err := schemautil.MapToDTO(m, o)
	if err != nil {
		diags.AddError("Failed to marshal map user config to dto", err.Error())
		return types.SetNull(types.ObjectType{AttrTypes: userConfigAttrs})
	}
	return schemautil.FlattenSetBlockNested[dtoUserConfig, tfoUserConfig](ctx, diags, flattenUserConfig, o, userConfigAttrs)
}
