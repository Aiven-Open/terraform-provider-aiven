// Code generated by user config generator. DO NOT EDIT.

package grafana

import (
	"context"
	"encoding/json"

	setvalidator "github.com/hashicorp/terraform-plugin-framework-validators/setvalidator"
	attr "github.com/hashicorp/terraform-plugin-framework/attr"
	datasource "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	diag "github.com/hashicorp/terraform-plugin-framework/diag"
	resource "github.com/hashicorp/terraform-plugin-framework/resource/schema"
	validator "github.com/hashicorp/terraform-plugin-framework/schema/validator"
	types "github.com/hashicorp/terraform-plugin-framework/types"

	schemautil "github.com/aiven/terraform-provider-aiven/internal/schemautil"
)

// NewResourceSchema returns resource schema
func NewResourceSchema() resource.SetNestedBlock {
	return resource.SetNestedBlock{
		Description: "Grafana user configurable settings",
		NestedObject: resource.NestedBlockObject{
			Attributes: map[string]resource.Attribute{
				"additional_backup_regions": resource.SetAttribute{
					Computed:    true,
					Description: "Additional Cloud Regions for Backup Replication.",
					ElementType: types.StringType,
					Optional:    true,
					Validators:  []validator.Set{setvalidator.SizeAtMost(1)},
				},
				"alerting_enabled": resource.BoolAttribute{
					Computed:    true,
					Description: "Enable or disable Grafana legacy alerting functionality. This should not be enabled with unified_alerting_enabled.",
					Optional:    true,
				},
				"alerting_error_or_timeout": resource.StringAttribute{
					Computed:    true,
					Description: "Default error or timeout setting for new alerting rules.",
					Optional:    true,
				},
				"alerting_max_annotations_to_keep": resource.Int64Attribute{
					Computed:    true,
					Description: "Max number of alert annotations that Grafana stores. 0 (default) keeps all alert annotations.",
					Optional:    true,
				},
				"alerting_nodata_or_nullvalues": resource.StringAttribute{
					Computed:    true,
					Description: "Default value for 'no data or null values' for new alerting rules.",
					Optional:    true,
				},
				"allow_embedding": resource.BoolAttribute{
					Computed:    true,
					Description: "Allow embedding Grafana dashboards with iframe/frame/object/embed tags. Disabled by default to limit impact of clickjacking.",
					Optional:    true,
				},
				"auth_basic_enabled": resource.BoolAttribute{
					Computed:    true,
					Description: "Enable or disable basic authentication form, used by Grafana built-in login.",
					Optional:    true,
				},
				"cookie_samesite": resource.StringAttribute{
					Computed:    true,
					Description: "Cookie SameSite attribute: 'strict' prevents sending cookie for cross-site requests, effectively disabling direct linking from other sites to Grafana. 'lax' is the default value.",
					Optional:    true,
				},
				"custom_domain": resource.StringAttribute{
					Computed:    true,
					Description: "Serve the web frontend using a custom CNAME pointing to the Aiven DNS name.",
					Optional:    true,
				},
				"dashboard_previews_enabled": resource.BoolAttribute{
					Computed:    true,
					Description: "This feature is new in Grafana 9 and is quite resource intensive. It may cause low-end plans to work more slowly while the dashboard previews are rendering.",
					Optional:    true,
				},
				"dashboards_min_refresh_interval": resource.StringAttribute{
					Computed:    true,
					Description: "Signed sequence of decimal numbers, followed by a unit suffix (ms, s, m, h, d), e.g. 30s, 1h.",
					Optional:    true,
				},
				"dashboards_versions_to_keep": resource.Int64Attribute{
					Computed:    true,
					Description: "Dashboard versions to keep per dashboard.",
					Optional:    true,
				},
				"dataproxy_send_user_header": resource.BoolAttribute{
					Computed:    true,
					Description: "Send 'X-Grafana-User' header to data source.",
					Optional:    true,
				},
				"dataproxy_timeout": resource.Int64Attribute{
					Computed:    true,
					Description: "Timeout for data proxy requests in seconds.",
					Optional:    true,
				},
				"disable_gravatar": resource.BoolAttribute{
					Computed:    true,
					Description: "Set to true to disable gravatar. Defaults to false (gravatar is enabled).",
					Optional:    true,
				},
				"editors_can_admin": resource.BoolAttribute{
					Computed:    true,
					Description: "Editors can manage folders, teams and dashboards created by them.",
					Optional:    true,
				},
				"google_analytics_ua_id": resource.StringAttribute{
					Computed:    true,
					Description: "Google Analytics ID.",
					Optional:    true,
				},
				"metrics_enabled": resource.BoolAttribute{
					Computed:    true,
					Description: "Enable Grafana /metrics endpoint.",
					Optional:    true,
				},
				"oauth_allow_insecure_email_lookup": resource.BoolAttribute{
					Computed:    true,
					Description: "Enforce user lookup based on email instead of the unique ID provided by the IdP.",
					Optional:    true,
				},
				"project_to_fork_from": resource.StringAttribute{
					Computed:    true,
					Description: "Name of another project to fork a service from. This has effect only when a new service is being created.",
					Optional:    true,
				},
				"recovery_basebackup_name": resource.StringAttribute{
					Computed:    true,
					Description: "Name of the basebackup to restore in forked service.",
					Optional:    true,
				},
				"service_to_fork_from": resource.StringAttribute{
					Computed:    true,
					Description: "Name of another service to fork from. This has effect only when a new service is being created.",
					Optional:    true,
				},
				"static_ips": resource.BoolAttribute{
					Computed:    true,
					Description: "Use static public IP addresses.",
					Optional:    true,
				},
				"unified_alerting_enabled": resource.BoolAttribute{
					Computed:    true,
					Description: "Enable or disable Grafana unified alerting functionality. By default this is enabled and any legacy alerts will be migrated on upgrade to Grafana 9+. To stay on legacy alerting, set unified_alerting_enabled to false and alerting_enabled to true. See https://grafana.com/docs/grafana/latest/alerting/set-up/migrating-alerts/ for more details.",
					Optional:    true,
				},
				"user_auto_assign_org": resource.BoolAttribute{
					Computed:    true,
					Description: "Auto-assign new users on signup to main organization. Defaults to false.",
					Optional:    true,
				},
				"user_auto_assign_org_role": resource.StringAttribute{
					Computed:    true,
					Description: "Set role for new signups. Defaults to Viewer.",
					Optional:    true,
				},
				"viewers_can_edit": resource.BoolAttribute{
					Computed:    true,
					Description: "Users with view-only permission can edit but not save dashboards.",
					Optional:    true,
				},
			},
			Blocks: map[string]resource.Block{
				"auth_azuread": resource.SetNestedBlock{
					Description: "Azure AD OAuth integration",
					NestedObject: resource.NestedBlockObject{Attributes: map[string]resource.Attribute{
						"allow_sign_up": resource.BoolAttribute{
							Computed:    true,
							Description: "Automatically sign-up users on successful sign-in.",
							Optional:    true,
						},
						"allowed_domains": resource.SetAttribute{
							Computed:    true,
							Description: "Allowed domains.",
							ElementType: types.StringType,
							Optional:    true,
							Validators:  []validator.Set{setvalidator.SizeAtMost(50)},
						},
						"allowed_groups": resource.SetAttribute{
							Computed:    true,
							Description: "Require users to belong to one of given groups.",
							ElementType: types.StringType,
							Optional:    true,
							Validators:  []validator.Set{setvalidator.SizeAtMost(50)},
						},
						"auth_url": resource.StringAttribute{
							Description: "Authorization URL.",
							Required:    true,
						},
						"client_id": resource.StringAttribute{
							Description: "Client ID from provider.",
							Required:    true,
						},
						"client_secret": resource.StringAttribute{
							Description: "Client secret from provider.",
							Required:    true,
						},
						"token_url": resource.StringAttribute{
							Description: "Token URL.",
							Required:    true,
						},
					}},
				},
				"auth_generic_oauth": resource.SetNestedBlock{
					Description: "Generic OAuth integration",
					NestedObject: resource.NestedBlockObject{Attributes: map[string]resource.Attribute{
						"allow_sign_up": resource.BoolAttribute{
							Computed:    true,
							Description: "Automatically sign-up users on successful sign-in.",
							Optional:    true,
						},
						"allowed_domains": resource.SetAttribute{
							Computed:    true,
							Description: "Allowed domains.",
							ElementType: types.StringType,
							Optional:    true,
							Validators:  []validator.Set{setvalidator.SizeAtMost(50)},
						},
						"allowed_organizations": resource.SetAttribute{
							Computed:    true,
							Description: "Require user to be member of one of the listed organizations.",
							ElementType: types.StringType,
							Optional:    true,
							Validators:  []validator.Set{setvalidator.SizeAtMost(50)},
						},
						"api_url": resource.StringAttribute{
							Description: "API URL.",
							Required:    true,
						},
						"auth_url": resource.StringAttribute{
							Description: "Authorization URL.",
							Required:    true,
						},
						"auto_login": resource.BoolAttribute{
							Computed:    true,
							Description: "Allow users to bypass the login screen and automatically log in.",
							Optional:    true,
						},
						"client_id": resource.StringAttribute{
							Description: "Client ID from provider.",
							Required:    true,
						},
						"client_secret": resource.StringAttribute{
							Description: "Client secret from provider.",
							Required:    true,
						},
						"name": resource.StringAttribute{
							Computed:    true,
							Description: "Name of the OAuth integration.",
							Optional:    true,
						},
						"scopes": resource.SetAttribute{
							Computed:    true,
							Description: "OAuth scopes.",
							ElementType: types.StringType,
							Optional:    true,
							Validators:  []validator.Set{setvalidator.SizeAtMost(50)},
						},
						"token_url": resource.StringAttribute{
							Description: "Token URL.",
							Required:    true,
						},
					}},
				},
				"auth_github": resource.SetNestedBlock{
					Description: "Github Auth integration",
					NestedObject: resource.NestedBlockObject{Attributes: map[string]resource.Attribute{
						"allow_sign_up": resource.BoolAttribute{
							Computed:    true,
							Description: "Automatically sign-up users on successful sign-in.",
							Optional:    true,
						},
						"allowed_organizations": resource.SetAttribute{
							Computed:    true,
							Description: "Require users to belong to one of given organizations.",
							ElementType: types.StringType,
							Optional:    true,
							Validators:  []validator.Set{setvalidator.SizeAtMost(50)},
						},
						"client_id": resource.StringAttribute{
							Description: "Client ID from provider.",
							Required:    true,
						},
						"client_secret": resource.StringAttribute{
							Description: "Client secret from provider.",
							Required:    true,
						},
						"team_ids": resource.SetAttribute{
							Computed:    true,
							Description: "Require users to belong to one of given team IDs.",
							ElementType: types.Int64Type,
							Optional:    true,
							Validators:  []validator.Set{setvalidator.SizeAtMost(50)},
						},
					}},
				},
				"auth_gitlab": resource.SetNestedBlock{
					Description: "GitLab Auth integration",
					NestedObject: resource.NestedBlockObject{Attributes: map[string]resource.Attribute{
						"allow_sign_up": resource.BoolAttribute{
							Computed:    true,
							Description: "Automatically sign-up users on successful sign-in.",
							Optional:    true,
						},
						"allowed_groups": resource.SetAttribute{
							Description: "Require users to belong to one of given groups.",
							ElementType: types.StringType,
							Required:    true,
							Validators:  []validator.Set{setvalidator.SizeAtMost(50)},
						},
						"api_url": resource.StringAttribute{
							Computed:    true,
							Description: "API URL. This only needs to be set when using self hosted GitLab.",
							Optional:    true,
						},
						"auth_url": resource.StringAttribute{
							Computed:    true,
							Description: "Authorization URL. This only needs to be set when using self hosted GitLab.",
							Optional:    true,
						},
						"client_id": resource.StringAttribute{
							Description: "Client ID from provider.",
							Required:    true,
						},
						"client_secret": resource.StringAttribute{
							Description: "Client secret from provider.",
							Required:    true,
						},
						"token_url": resource.StringAttribute{
							Computed:    true,
							Description: "Token URL. This only needs to be set when using self hosted GitLab.",
							Optional:    true,
						},
					}},
				},
				"auth_google": resource.SetNestedBlock{
					Description: "Google Auth integration",
					NestedObject: resource.NestedBlockObject{Attributes: map[string]resource.Attribute{
						"allow_sign_up": resource.BoolAttribute{
							Computed:    true,
							Description: "Automatically sign-up users on successful sign-in.",
							Optional:    true,
						},
						"allowed_domains": resource.SetAttribute{
							Description: "Domains allowed to sign-in to this Grafana.",
							ElementType: types.StringType,
							Required:    true,
							Validators:  []validator.Set{setvalidator.SizeAtMost(64)},
						},
						"client_id": resource.StringAttribute{
							Description: "Client ID from provider.",
							Required:    true,
						},
						"client_secret": resource.StringAttribute{
							Description: "Client secret from provider.",
							Required:    true,
						},
					}},
				},
				"date_formats": resource.SetNestedBlock{
					Description: "Grafana date format specifications",
					NestedObject: resource.NestedBlockObject{Attributes: map[string]resource.Attribute{
						"default_timezone": resource.StringAttribute{
							Computed:    true,
							Description: "Default time zone for user preferences. Value 'browser' uses browser local time zone.",
							Optional:    true,
						},
						"full_date": resource.StringAttribute{
							Computed:    true,
							Description: "Moment.js style format string for cases where full date is shown.",
							Optional:    true,
						},
						"interval_day": resource.StringAttribute{
							Computed:    true,
							Description: "Moment.js style format string used when a time requiring day accuracy is shown.",
							Optional:    true,
						},
						"interval_hour": resource.StringAttribute{
							Computed:    true,
							Description: "Moment.js style format string used when a time requiring hour accuracy is shown.",
							Optional:    true,
						},
						"interval_minute": resource.StringAttribute{
							Computed:    true,
							Description: "Moment.js style format string used when a time requiring minute accuracy is shown.",
							Optional:    true,
						},
						"interval_month": resource.StringAttribute{
							Computed:    true,
							Description: "Moment.js style format string used when a time requiring month accuracy is shown.",
							Optional:    true,
						},
						"interval_second": resource.StringAttribute{
							Computed:    true,
							Description: "Moment.js style format string used when a time requiring second accuracy is shown.",
							Optional:    true,
						},
						"interval_year": resource.StringAttribute{
							Computed:    true,
							Description: "Moment.js style format string used when a time requiring year accuracy is shown.",
							Optional:    true,
						},
					}},
				},
				"external_image_storage": resource.SetNestedBlock{
					Description: "External image store settings",
					NestedObject: resource.NestedBlockObject{Attributes: map[string]resource.Attribute{
						"access_key": resource.StringAttribute{
							Description: "S3 access key. Requires permissions to the S3 bucket for the s3:PutObject and s3:PutObjectAcl actions.",
							Required:    true,
						},
						"bucket_url": resource.StringAttribute{
							Description: "Bucket URL for S3.",
							Required:    true,
						},
						"provider": resource.StringAttribute{
							Description: "Provider type.",
							Required:    true,
						},
						"secret_key": resource.StringAttribute{
							Description: "S3 secret key.",
							Required:    true,
						},
					}},
				},
				"ip_filter": resource.SetNestedBlock{
					Description: "Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'",
					NestedObject: resource.NestedBlockObject{Attributes: map[string]resource.Attribute{
						"description": resource.StringAttribute{
							Computed:    true,
							Description: "Description for IP filter list entry.",
							Optional:    true,
						},
						"network": resource.StringAttribute{
							Description: "CIDR address block.",
							Required:    true,
						},
					}},
					Validators: []validator.Set{setvalidator.SizeAtMost(1024)},
				},
				"private_access": resource.SetNestedBlock{
					Description: "Allow access to selected service ports from private networks",
					NestedObject: resource.NestedBlockObject{Attributes: map[string]resource.Attribute{"grafana": resource.BoolAttribute{
						Computed:    true,
						Description: "Allow clients to connect to grafana with a DNS name that always resolves to the service's private IP addresses. Only available in certain network locations.",
						Optional:    true,
					}}},
				},
				"privatelink_access": resource.SetNestedBlock{
					Description: "Allow access to selected service components through Privatelink",
					NestedObject: resource.NestedBlockObject{Attributes: map[string]resource.Attribute{"grafana": resource.BoolAttribute{
						Computed:    true,
						Description: "Enable grafana.",
						Optional:    true,
					}}},
				},
				"public_access": resource.SetNestedBlock{
					Description: "Allow access to selected service ports from the public Internet",
					NestedObject: resource.NestedBlockObject{Attributes: map[string]resource.Attribute{"grafana": resource.BoolAttribute{
						Computed:    true,
						Description: "Allow clients to connect to grafana from the public internet for service nodes that are in a project VPC or another type of private network.",
						Optional:    true,
					}}},
				},
				"smtp_server": resource.SetNestedBlock{
					Description: "SMTP server settings",
					NestedObject: resource.NestedBlockObject{Attributes: map[string]resource.Attribute{
						"from_address": resource.StringAttribute{
							Description: "Address used for sending emails.",
							Required:    true,
						},
						"from_name": resource.StringAttribute{
							Computed:    true,
							Description: "Name used in outgoing emails, defaults to Grafana.",
							Optional:    true,
						},
						"host": resource.StringAttribute{
							Description: "Server hostname or IP.",
							Required:    true,
						},
						"password": resource.StringAttribute{
							Computed:    true,
							Description: "Password for SMTP authentication.",
							Optional:    true,
						},
						"port": resource.Int64Attribute{
							Description: "SMTP server port.",
							Required:    true,
						},
						"skip_verify": resource.BoolAttribute{
							Computed:    true,
							Description: "Skip verifying server certificate. Defaults to false.",
							Optional:    true,
						},
						"starttls_policy": resource.StringAttribute{
							Computed:    true,
							Description: "Either OpportunisticStartTLS, MandatoryStartTLS or NoStartTLS. Default is OpportunisticStartTLS.",
							Optional:    true,
						},
						"username": resource.StringAttribute{
							Computed:    true,
							Description: "Username for SMTP authentication.",
							Optional:    true,
						},
					}},
				},
			},
		},
		Validators: []validator.Set{setvalidator.SizeAtMost(1)},
	}
}

// NewDataSourceSchema returns datasource schema
func NewDataSourceSchema() datasource.SetNestedBlock {
	return datasource.SetNestedBlock{
		Description: "Grafana user configurable settings",
		NestedObject: datasource.NestedBlockObject{
			Attributes: map[string]datasource.Attribute{
				"additional_backup_regions": datasource.SetAttribute{
					Computed:    true,
					Description: "Additional Cloud Regions for Backup Replication.",
					ElementType: types.StringType,
					Validators:  []validator.Set{setvalidator.SizeAtMost(1)},
				},
				"alerting_enabled": datasource.BoolAttribute{
					Computed:    true,
					Description: "Enable or disable Grafana legacy alerting functionality. This should not be enabled with unified_alerting_enabled.",
				},
				"alerting_error_or_timeout": datasource.StringAttribute{
					Computed:    true,
					Description: "Default error or timeout setting for new alerting rules.",
				},
				"alerting_max_annotations_to_keep": datasource.Int64Attribute{
					Computed:    true,
					Description: "Max number of alert annotations that Grafana stores. 0 (default) keeps all alert annotations.",
				},
				"alerting_nodata_or_nullvalues": datasource.StringAttribute{
					Computed:    true,
					Description: "Default value for 'no data or null values' for new alerting rules.",
				},
				"allow_embedding": datasource.BoolAttribute{
					Computed:    true,
					Description: "Allow embedding Grafana dashboards with iframe/frame/object/embed tags. Disabled by default to limit impact of clickjacking.",
				},
				"auth_basic_enabled": datasource.BoolAttribute{
					Computed:    true,
					Description: "Enable or disable basic authentication form, used by Grafana built-in login.",
				},
				"cookie_samesite": datasource.StringAttribute{
					Computed:    true,
					Description: "Cookie SameSite attribute: 'strict' prevents sending cookie for cross-site requests, effectively disabling direct linking from other sites to Grafana. 'lax' is the default value.",
				},
				"custom_domain": datasource.StringAttribute{
					Computed:    true,
					Description: "Serve the web frontend using a custom CNAME pointing to the Aiven DNS name.",
				},
				"dashboard_previews_enabled": datasource.BoolAttribute{
					Computed:    true,
					Description: "This feature is new in Grafana 9 and is quite resource intensive. It may cause low-end plans to work more slowly while the dashboard previews are rendering.",
				},
				"dashboards_min_refresh_interval": datasource.StringAttribute{
					Computed:    true,
					Description: "Signed sequence of decimal numbers, followed by a unit suffix (ms, s, m, h, d), e.g. 30s, 1h.",
				},
				"dashboards_versions_to_keep": datasource.Int64Attribute{
					Computed:    true,
					Description: "Dashboard versions to keep per dashboard.",
				},
				"dataproxy_send_user_header": datasource.BoolAttribute{
					Computed:    true,
					Description: "Send 'X-Grafana-User' header to data source.",
				},
				"dataproxy_timeout": datasource.Int64Attribute{
					Computed:    true,
					Description: "Timeout for data proxy requests in seconds.",
				},
				"disable_gravatar": datasource.BoolAttribute{
					Computed:    true,
					Description: "Set to true to disable gravatar. Defaults to false (gravatar is enabled).",
				},
				"editors_can_admin": datasource.BoolAttribute{
					Computed:    true,
					Description: "Editors can manage folders, teams and dashboards created by them.",
				},
				"google_analytics_ua_id": datasource.StringAttribute{
					Computed:    true,
					Description: "Google Analytics ID.",
				},
				"metrics_enabled": datasource.BoolAttribute{
					Computed:    true,
					Description: "Enable Grafana /metrics endpoint.",
				},
				"oauth_allow_insecure_email_lookup": datasource.BoolAttribute{
					Computed:    true,
					Description: "Enforce user lookup based on email instead of the unique ID provided by the IdP.",
				},
				"project_to_fork_from": datasource.StringAttribute{
					Computed:    true,
					Description: "Name of another project to fork a service from. This has effect only when a new service is being created.",
				},
				"recovery_basebackup_name": datasource.StringAttribute{
					Computed:    true,
					Description: "Name of the basebackup to restore in forked service.",
				},
				"service_to_fork_from": datasource.StringAttribute{
					Computed:    true,
					Description: "Name of another service to fork from. This has effect only when a new service is being created.",
				},
				"static_ips": datasource.BoolAttribute{
					Computed:    true,
					Description: "Use static public IP addresses.",
				},
				"unified_alerting_enabled": datasource.BoolAttribute{
					Computed:    true,
					Description: "Enable or disable Grafana unified alerting functionality. By default this is enabled and any legacy alerts will be migrated on upgrade to Grafana 9+. To stay on legacy alerting, set unified_alerting_enabled to false and alerting_enabled to true. See https://grafana.com/docs/grafana/latest/alerting/set-up/migrating-alerts/ for more details.",
				},
				"user_auto_assign_org": datasource.BoolAttribute{
					Computed:    true,
					Description: "Auto-assign new users on signup to main organization. Defaults to false.",
				},
				"user_auto_assign_org_role": datasource.StringAttribute{
					Computed:    true,
					Description: "Set role for new signups. Defaults to Viewer.",
				},
				"viewers_can_edit": datasource.BoolAttribute{
					Computed:    true,
					Description: "Users with view-only permission can edit but not save dashboards.",
				},
			},
			Blocks: map[string]datasource.Block{
				"auth_azuread": datasource.SetNestedBlock{
					Description: "Azure AD OAuth integration",
					NestedObject: datasource.NestedBlockObject{Attributes: map[string]datasource.Attribute{
						"allow_sign_up": datasource.BoolAttribute{
							Computed:    true,
							Description: "Automatically sign-up users on successful sign-in.",
						},
						"allowed_domains": datasource.SetAttribute{
							Computed:    true,
							Description: "Allowed domains.",
							ElementType: types.StringType,
							Validators:  []validator.Set{setvalidator.SizeAtMost(50)},
						},
						"allowed_groups": datasource.SetAttribute{
							Computed:    true,
							Description: "Require users to belong to one of given groups.",
							ElementType: types.StringType,
							Validators:  []validator.Set{setvalidator.SizeAtMost(50)},
						},
						"auth_url": datasource.StringAttribute{
							Computed:    true,
							Description: "Authorization URL.",
						},
						"client_id": datasource.StringAttribute{
							Computed:    true,
							Description: "Client ID from provider.",
						},
						"client_secret": datasource.StringAttribute{
							Computed:    true,
							Description: "Client secret from provider.",
						},
						"token_url": datasource.StringAttribute{
							Computed:    true,
							Description: "Token URL.",
						},
					}},
				},
				"auth_generic_oauth": datasource.SetNestedBlock{
					Description: "Generic OAuth integration",
					NestedObject: datasource.NestedBlockObject{Attributes: map[string]datasource.Attribute{
						"allow_sign_up": datasource.BoolAttribute{
							Computed:    true,
							Description: "Automatically sign-up users on successful sign-in.",
						},
						"allowed_domains": datasource.SetAttribute{
							Computed:    true,
							Description: "Allowed domains.",
							ElementType: types.StringType,
							Validators:  []validator.Set{setvalidator.SizeAtMost(50)},
						},
						"allowed_organizations": datasource.SetAttribute{
							Computed:    true,
							Description: "Require user to be member of one of the listed organizations.",
							ElementType: types.StringType,
							Validators:  []validator.Set{setvalidator.SizeAtMost(50)},
						},
						"api_url": datasource.StringAttribute{
							Computed:    true,
							Description: "API URL.",
						},
						"auth_url": datasource.StringAttribute{
							Computed:    true,
							Description: "Authorization URL.",
						},
						"auto_login": datasource.BoolAttribute{
							Computed:    true,
							Description: "Allow users to bypass the login screen and automatically log in.",
						},
						"client_id": datasource.StringAttribute{
							Computed:    true,
							Description: "Client ID from provider.",
						},
						"client_secret": datasource.StringAttribute{
							Computed:    true,
							Description: "Client secret from provider.",
						},
						"name": datasource.StringAttribute{
							Computed:    true,
							Description: "Name of the OAuth integration.",
						},
						"scopes": datasource.SetAttribute{
							Computed:    true,
							Description: "OAuth scopes.",
							ElementType: types.StringType,
							Validators:  []validator.Set{setvalidator.SizeAtMost(50)},
						},
						"token_url": datasource.StringAttribute{
							Computed:    true,
							Description: "Token URL.",
						},
					}},
				},
				"auth_github": datasource.SetNestedBlock{
					Description: "Github Auth integration",
					NestedObject: datasource.NestedBlockObject{Attributes: map[string]datasource.Attribute{
						"allow_sign_up": datasource.BoolAttribute{
							Computed:    true,
							Description: "Automatically sign-up users on successful sign-in.",
						},
						"allowed_organizations": datasource.SetAttribute{
							Computed:    true,
							Description: "Require users to belong to one of given organizations.",
							ElementType: types.StringType,
							Validators:  []validator.Set{setvalidator.SizeAtMost(50)},
						},
						"client_id": datasource.StringAttribute{
							Computed:    true,
							Description: "Client ID from provider.",
						},
						"client_secret": datasource.StringAttribute{
							Computed:    true,
							Description: "Client secret from provider.",
						},
						"team_ids": datasource.SetAttribute{
							Computed:    true,
							Description: "Require users to belong to one of given team IDs.",
							ElementType: types.Int64Type,
							Validators:  []validator.Set{setvalidator.SizeAtMost(50)},
						},
					}},
				},
				"auth_gitlab": datasource.SetNestedBlock{
					Description: "GitLab Auth integration",
					NestedObject: datasource.NestedBlockObject{Attributes: map[string]datasource.Attribute{
						"allow_sign_up": datasource.BoolAttribute{
							Computed:    true,
							Description: "Automatically sign-up users on successful sign-in.",
						},
						"allowed_groups": datasource.SetAttribute{
							Computed:    true,
							Description: "Require users to belong to one of given groups.",
							ElementType: types.StringType,
							Validators:  []validator.Set{setvalidator.SizeAtMost(50)},
						},
						"api_url": datasource.StringAttribute{
							Computed:    true,
							Description: "API URL. This only needs to be set when using self hosted GitLab.",
						},
						"auth_url": datasource.StringAttribute{
							Computed:    true,
							Description: "Authorization URL. This only needs to be set when using self hosted GitLab.",
						},
						"client_id": datasource.StringAttribute{
							Computed:    true,
							Description: "Client ID from provider.",
						},
						"client_secret": datasource.StringAttribute{
							Computed:    true,
							Description: "Client secret from provider.",
						},
						"token_url": datasource.StringAttribute{
							Computed:    true,
							Description: "Token URL. This only needs to be set when using self hosted GitLab.",
						},
					}},
				},
				"auth_google": datasource.SetNestedBlock{
					Description: "Google Auth integration",
					NestedObject: datasource.NestedBlockObject{Attributes: map[string]datasource.Attribute{
						"allow_sign_up": datasource.BoolAttribute{
							Computed:    true,
							Description: "Automatically sign-up users on successful sign-in.",
						},
						"allowed_domains": datasource.SetAttribute{
							Computed:    true,
							Description: "Domains allowed to sign-in to this Grafana.",
							ElementType: types.StringType,
							Validators:  []validator.Set{setvalidator.SizeAtMost(64)},
						},
						"client_id": datasource.StringAttribute{
							Computed:    true,
							Description: "Client ID from provider.",
						},
						"client_secret": datasource.StringAttribute{
							Computed:    true,
							Description: "Client secret from provider.",
						},
					}},
				},
				"date_formats": datasource.SetNestedBlock{
					Description: "Grafana date format specifications",
					NestedObject: datasource.NestedBlockObject{Attributes: map[string]datasource.Attribute{
						"default_timezone": datasource.StringAttribute{
							Computed:    true,
							Description: "Default time zone for user preferences. Value 'browser' uses browser local time zone.",
						},
						"full_date": datasource.StringAttribute{
							Computed:    true,
							Description: "Moment.js style format string for cases where full date is shown.",
						},
						"interval_day": datasource.StringAttribute{
							Computed:    true,
							Description: "Moment.js style format string used when a time requiring day accuracy is shown.",
						},
						"interval_hour": datasource.StringAttribute{
							Computed:    true,
							Description: "Moment.js style format string used when a time requiring hour accuracy is shown.",
						},
						"interval_minute": datasource.StringAttribute{
							Computed:    true,
							Description: "Moment.js style format string used when a time requiring minute accuracy is shown.",
						},
						"interval_month": datasource.StringAttribute{
							Computed:    true,
							Description: "Moment.js style format string used when a time requiring month accuracy is shown.",
						},
						"interval_second": datasource.StringAttribute{
							Computed:    true,
							Description: "Moment.js style format string used when a time requiring second accuracy is shown.",
						},
						"interval_year": datasource.StringAttribute{
							Computed:    true,
							Description: "Moment.js style format string used when a time requiring year accuracy is shown.",
						},
					}},
				},
				"external_image_storage": datasource.SetNestedBlock{
					Description: "External image store settings",
					NestedObject: datasource.NestedBlockObject{Attributes: map[string]datasource.Attribute{
						"access_key": datasource.StringAttribute{
							Computed:    true,
							Description: "S3 access key. Requires permissions to the S3 bucket for the s3:PutObject and s3:PutObjectAcl actions.",
						},
						"bucket_url": datasource.StringAttribute{
							Computed:    true,
							Description: "Bucket URL for S3.",
						},
						"provider": datasource.StringAttribute{
							Computed:    true,
							Description: "Provider type.",
						},
						"secret_key": datasource.StringAttribute{
							Computed:    true,
							Description: "S3 secret key.",
						},
					}},
				},
				"ip_filter": datasource.SetNestedBlock{
					Description: "Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'",
					NestedObject: datasource.NestedBlockObject{Attributes: map[string]datasource.Attribute{
						"description": datasource.StringAttribute{
							Computed:    true,
							Description: "Description for IP filter list entry.",
						},
						"network": datasource.StringAttribute{
							Computed:    true,
							Description: "CIDR address block.",
						},
					}},
					Validators: []validator.Set{setvalidator.SizeAtMost(1024)},
				},
				"private_access": datasource.SetNestedBlock{
					Description: "Allow access to selected service ports from private networks",
					NestedObject: datasource.NestedBlockObject{Attributes: map[string]datasource.Attribute{"grafana": datasource.BoolAttribute{
						Computed:    true,
						Description: "Allow clients to connect to grafana with a DNS name that always resolves to the service's private IP addresses. Only available in certain network locations.",
					}}},
				},
				"privatelink_access": datasource.SetNestedBlock{
					Description: "Allow access to selected service components through Privatelink",
					NestedObject: datasource.NestedBlockObject{Attributes: map[string]datasource.Attribute{"grafana": datasource.BoolAttribute{
						Computed:    true,
						Description: "Enable grafana.",
					}}},
				},
				"public_access": datasource.SetNestedBlock{
					Description: "Allow access to selected service ports from the public Internet",
					NestedObject: datasource.NestedBlockObject{Attributes: map[string]datasource.Attribute{"grafana": datasource.BoolAttribute{
						Computed:    true,
						Description: "Allow clients to connect to grafana from the public internet for service nodes that are in a project VPC or another type of private network.",
					}}},
				},
				"smtp_server": datasource.SetNestedBlock{
					Description: "SMTP server settings",
					NestedObject: datasource.NestedBlockObject{Attributes: map[string]datasource.Attribute{
						"from_address": datasource.StringAttribute{
							Computed:    true,
							Description: "Address used for sending emails.",
						},
						"from_name": datasource.StringAttribute{
							Computed:    true,
							Description: "Name used in outgoing emails, defaults to Grafana.",
						},
						"host": datasource.StringAttribute{
							Computed:    true,
							Description: "Server hostname or IP.",
						},
						"password": datasource.StringAttribute{
							Computed:    true,
							Description: "Password for SMTP authentication.",
						},
						"port": datasource.Int64Attribute{
							Computed:    true,
							Description: "SMTP server port.",
						},
						"skip_verify": datasource.BoolAttribute{
							Computed:    true,
							Description: "Skip verifying server certificate. Defaults to false.",
						},
						"starttls_policy": datasource.StringAttribute{
							Computed:    true,
							Description: "Either OpportunisticStartTLS, MandatoryStartTLS or NoStartTLS. Default is OpportunisticStartTLS.",
						},
						"username": datasource.StringAttribute{
							Computed:    true,
							Description: "Username for SMTP authentication.",
						},
					}},
				},
			},
		},
		Validators: []validator.Set{setvalidator.SizeAtMost(1)},
	}
}

// tfoUserConfig Grafana user configurable settings
type tfoUserConfig struct {
	AdditionalBackupRegions       types.Set    `tfsdk:"additional_backup_regions"`
	AlertingEnabled               types.Bool   `tfsdk:"alerting_enabled"`
	AlertingErrorOrTimeout        types.String `tfsdk:"alerting_error_or_timeout"`
	AlertingMaxAnnotationsToKeep  types.Int64  `tfsdk:"alerting_max_annotations_to_keep"`
	AlertingNodataOrNullvalues    types.String `tfsdk:"alerting_nodata_or_nullvalues"`
	AllowEmbedding                types.Bool   `tfsdk:"allow_embedding"`
	AuthAzuread                   types.Set    `tfsdk:"auth_azuread"`
	AuthBasicEnabled              types.Bool   `tfsdk:"auth_basic_enabled"`
	AuthGenericOauth              types.Set    `tfsdk:"auth_generic_oauth"`
	AuthGithub                    types.Set    `tfsdk:"auth_github"`
	AuthGitlab                    types.Set    `tfsdk:"auth_gitlab"`
	AuthGoogle                    types.Set    `tfsdk:"auth_google"`
	CookieSamesite                types.String `tfsdk:"cookie_samesite"`
	CustomDomain                  types.String `tfsdk:"custom_domain"`
	DashboardPreviewsEnabled      types.Bool   `tfsdk:"dashboard_previews_enabled"`
	DashboardsMinRefreshInterval  types.String `tfsdk:"dashboards_min_refresh_interval"`
	DashboardsVersionsToKeep      types.Int64  `tfsdk:"dashboards_versions_to_keep"`
	DataproxySendUserHeader       types.Bool   `tfsdk:"dataproxy_send_user_header"`
	DataproxyTimeout              types.Int64  `tfsdk:"dataproxy_timeout"`
	DateFormats                   types.Set    `tfsdk:"date_formats"`
	DisableGravatar               types.Bool   `tfsdk:"disable_gravatar"`
	EditorsCanAdmin               types.Bool   `tfsdk:"editors_can_admin"`
	ExternalImageStorage          types.Set    `tfsdk:"external_image_storage"`
	GoogleAnalyticsUaId           types.String `tfsdk:"google_analytics_ua_id"`
	IpFilter                      types.Set    `tfsdk:"ip_filter"`
	MetricsEnabled                types.Bool   `tfsdk:"metrics_enabled"`
	OauthAllowInsecureEmailLookup types.Bool   `tfsdk:"oauth_allow_insecure_email_lookup"`
	PrivateAccess                 types.Set    `tfsdk:"private_access"`
	PrivatelinkAccess             types.Set    `tfsdk:"privatelink_access"`
	ProjectToForkFrom             types.String `tfsdk:"project_to_fork_from"`
	PublicAccess                  types.Set    `tfsdk:"public_access"`
	RecoveryBasebackupName        types.String `tfsdk:"recovery_basebackup_name"`
	ServiceToForkFrom             types.String `tfsdk:"service_to_fork_from"`
	SmtpServer                    types.Set    `tfsdk:"smtp_server"`
	StaticIps                     types.Bool   `tfsdk:"static_ips"`
	UnifiedAlertingEnabled        types.Bool   `tfsdk:"unified_alerting_enabled"`
	UserAutoAssignOrg             types.Bool   `tfsdk:"user_auto_assign_org"`
	UserAutoAssignOrgRole         types.String `tfsdk:"user_auto_assign_org_role"`
	ViewersCanEdit                types.Bool   `tfsdk:"viewers_can_edit"`
}

// dtoUserConfig request/response object
type dtoUserConfig struct {
	AdditionalBackupRegions       []string                 `groups:"create,update" json:"additional_backup_regions,omitempty"`
	AlertingEnabled               *bool                    `groups:"create,update" json:"alerting_enabled,omitempty"`
	AlertingErrorOrTimeout        *string                  `groups:"create,update" json:"alerting_error_or_timeout,omitempty"`
	AlertingMaxAnnotationsToKeep  *int64                   `groups:"create,update" json:"alerting_max_annotations_to_keep,omitempty"`
	AlertingNodataOrNullvalues    *string                  `groups:"create,update" json:"alerting_nodata_or_nullvalues,omitempty"`
	AllowEmbedding                *bool                    `groups:"create,update" json:"allow_embedding,omitempty"`
	AuthAzuread                   *dtoAuthAzuread          `groups:"create,update" json:"auth_azuread,omitempty"`
	AuthBasicEnabled              *bool                    `groups:"create,update" json:"auth_basic_enabled,omitempty"`
	AuthGenericOauth              *dtoAuthGenericOauth     `groups:"create,update" json:"auth_generic_oauth,omitempty"`
	AuthGithub                    *dtoAuthGithub           `groups:"create,update" json:"auth_github,omitempty"`
	AuthGitlab                    *dtoAuthGitlab           `groups:"create,update" json:"auth_gitlab,omitempty"`
	AuthGoogle                    *dtoAuthGoogle           `groups:"create,update" json:"auth_google,omitempty"`
	CookieSamesite                *string                  `groups:"create,update" json:"cookie_samesite,omitempty"`
	CustomDomain                  *string                  `groups:"create,update" json:"custom_domain,omitempty"`
	DashboardPreviewsEnabled      *bool                    `groups:"create,update" json:"dashboard_previews_enabled,omitempty"`
	DashboardsMinRefreshInterval  *string                  `groups:"create,update" json:"dashboards_min_refresh_interval,omitempty"`
	DashboardsVersionsToKeep      *int64                   `groups:"create,update" json:"dashboards_versions_to_keep,omitempty"`
	DataproxySendUserHeader       *bool                    `groups:"create,update" json:"dataproxy_send_user_header,omitempty"`
	DataproxyTimeout              *int64                   `groups:"create,update" json:"dataproxy_timeout,omitempty"`
	DateFormats                   *dtoDateFormats          `groups:"create,update" json:"date_formats,omitempty"`
	DisableGravatar               *bool                    `groups:"create,update" json:"disable_gravatar,omitempty"`
	EditorsCanAdmin               *bool                    `groups:"create,update" json:"editors_can_admin,omitempty"`
	ExternalImageStorage          *dtoExternalImageStorage `groups:"create,update" json:"external_image_storage,omitempty"`
	GoogleAnalyticsUaId           *string                  `groups:"create,update" json:"google_analytics_ua_id,omitempty"`
	IpFilter                      []*dtoIpFilter           `groups:"create,update" json:"ip_filter,omitempty"`
	MetricsEnabled                *bool                    `groups:"create,update" json:"metrics_enabled,omitempty"`
	OauthAllowInsecureEmailLookup *bool                    `groups:"create,update" json:"oauth_allow_insecure_email_lookup,omitempty"`
	PrivateAccess                 *dtoPrivateAccess        `groups:"create,update" json:"private_access,omitempty"`
	PrivatelinkAccess             *dtoPrivatelinkAccess    `groups:"create,update" json:"privatelink_access,omitempty"`
	ProjectToForkFrom             *string                  `groups:"create" json:"project_to_fork_from,omitempty"`
	PublicAccess                  *dtoPublicAccess         `groups:"create,update" json:"public_access,omitempty"`
	RecoveryBasebackupName        *string                  `groups:"create,update" json:"recovery_basebackup_name,omitempty"`
	ServiceToForkFrom             *string                  `groups:"create" json:"service_to_fork_from,omitempty"`
	SmtpServer                    *dtoSmtpServer           `groups:"create,update" json:"smtp_server,omitempty"`
	StaticIps                     *bool                    `groups:"create,update" json:"static_ips,omitempty"`
	UnifiedAlertingEnabled        *bool                    `groups:"create,update" json:"unified_alerting_enabled,omitempty"`
	UserAutoAssignOrg             *bool                    `groups:"create,update" json:"user_auto_assign_org,omitempty"`
	UserAutoAssignOrgRole         *string                  `groups:"create,update" json:"user_auto_assign_org_role,omitempty"`
	ViewersCanEdit                *bool                    `groups:"create,update" json:"viewers_can_edit,omitempty"`
}

// expandUserConfig expands tf object into dto object
func expandUserConfig(ctx context.Context, diags diag.Diagnostics, o *tfoUserConfig) *dtoUserConfig {
	additionalBackupRegionsVar := schemautil.ExpandSet[string](ctx, diags, o.AdditionalBackupRegions)
	if diags.HasError() {
		return nil
	}
	authAzureadVar := schemautil.ExpandSetBlockNested(ctx, diags, expandAuthAzuread, o.AuthAzuread)
	if diags.HasError() {
		return nil
	}
	authGenericOauthVar := schemautil.ExpandSetBlockNested(ctx, diags, expandAuthGenericOauth, o.AuthGenericOauth)
	if diags.HasError() {
		return nil
	}
	authGithubVar := schemautil.ExpandSetBlockNested(ctx, diags, expandAuthGithub, o.AuthGithub)
	if diags.HasError() {
		return nil
	}
	authGitlabVar := schemautil.ExpandSetBlockNested(ctx, diags, expandAuthGitlab, o.AuthGitlab)
	if diags.HasError() {
		return nil
	}
	authGoogleVar := schemautil.ExpandSetBlockNested(ctx, diags, expandAuthGoogle, o.AuthGoogle)
	if diags.HasError() {
		return nil
	}
	dateFormatsVar := schemautil.ExpandSetBlockNested(ctx, diags, expandDateFormats, o.DateFormats)
	if diags.HasError() {
		return nil
	}
	externalImageStorageVar := schemautil.ExpandSetBlockNested(ctx, diags, expandExternalImageStorage, o.ExternalImageStorage)
	if diags.HasError() {
		return nil
	}
	ipFilterVar := schemautil.ExpandSetNested(ctx, diags, expandIpFilter, o.IpFilter)
	if diags.HasError() {
		return nil
	}
	privateAccessVar := schemautil.ExpandSetBlockNested(ctx, diags, expandPrivateAccess, o.PrivateAccess)
	if diags.HasError() {
		return nil
	}
	privatelinkAccessVar := schemautil.ExpandSetBlockNested(ctx, diags, expandPrivatelinkAccess, o.PrivatelinkAccess)
	if diags.HasError() {
		return nil
	}
	publicAccessVar := schemautil.ExpandSetBlockNested(ctx, diags, expandPublicAccess, o.PublicAccess)
	if diags.HasError() {
		return nil
	}
	smtpServerVar := schemautil.ExpandSetBlockNested(ctx, diags, expandSmtpServer, o.SmtpServer)
	if diags.HasError() {
		return nil
	}
	return &dtoUserConfig{
		AdditionalBackupRegions:       additionalBackupRegionsVar,
		AlertingEnabled:               schemautil.ValueBoolPointer(o.AlertingEnabled),
		AlertingErrorOrTimeout:        schemautil.ValueStringPointer(o.AlertingErrorOrTimeout),
		AlertingMaxAnnotationsToKeep:  schemautil.ValueInt64Pointer(o.AlertingMaxAnnotationsToKeep),
		AlertingNodataOrNullvalues:    schemautil.ValueStringPointer(o.AlertingNodataOrNullvalues),
		AllowEmbedding:                schemautil.ValueBoolPointer(o.AllowEmbedding),
		AuthAzuread:                   authAzureadVar,
		AuthBasicEnabled:              schemautil.ValueBoolPointer(o.AuthBasicEnabled),
		AuthGenericOauth:              authGenericOauthVar,
		AuthGithub:                    authGithubVar,
		AuthGitlab:                    authGitlabVar,
		AuthGoogle:                    authGoogleVar,
		CookieSamesite:                schemautil.ValueStringPointer(o.CookieSamesite),
		CustomDomain:                  schemautil.ValueStringPointer(o.CustomDomain),
		DashboardPreviewsEnabled:      schemautil.ValueBoolPointer(o.DashboardPreviewsEnabled),
		DashboardsMinRefreshInterval:  schemautil.ValueStringPointer(o.DashboardsMinRefreshInterval),
		DashboardsVersionsToKeep:      schemautil.ValueInt64Pointer(o.DashboardsVersionsToKeep),
		DataproxySendUserHeader:       schemautil.ValueBoolPointer(o.DataproxySendUserHeader),
		DataproxyTimeout:              schemautil.ValueInt64Pointer(o.DataproxyTimeout),
		DateFormats:                   dateFormatsVar,
		DisableGravatar:               schemautil.ValueBoolPointer(o.DisableGravatar),
		EditorsCanAdmin:               schemautil.ValueBoolPointer(o.EditorsCanAdmin),
		ExternalImageStorage:          externalImageStorageVar,
		GoogleAnalyticsUaId:           schemautil.ValueStringPointer(o.GoogleAnalyticsUaId),
		IpFilter:                      ipFilterVar,
		MetricsEnabled:                schemautil.ValueBoolPointer(o.MetricsEnabled),
		OauthAllowInsecureEmailLookup: schemautil.ValueBoolPointer(o.OauthAllowInsecureEmailLookup),
		PrivateAccess:                 privateAccessVar,
		PrivatelinkAccess:             privatelinkAccessVar,
		ProjectToForkFrom:             schemautil.ValueStringPointer(o.ProjectToForkFrom),
		PublicAccess:                  publicAccessVar,
		RecoveryBasebackupName:        schemautil.ValueStringPointer(o.RecoveryBasebackupName),
		ServiceToForkFrom:             schemautil.ValueStringPointer(o.ServiceToForkFrom),
		SmtpServer:                    smtpServerVar,
		StaticIps:                     schemautil.ValueBoolPointer(o.StaticIps),
		UnifiedAlertingEnabled:        schemautil.ValueBoolPointer(o.UnifiedAlertingEnabled),
		UserAutoAssignOrg:             schemautil.ValueBoolPointer(o.UserAutoAssignOrg),
		UserAutoAssignOrgRole:         schemautil.ValueStringPointer(o.UserAutoAssignOrgRole),
		ViewersCanEdit:                schemautil.ValueBoolPointer(o.ViewersCanEdit),
	}
}

// flattenUserConfig flattens dto object into tf object
func flattenUserConfig(ctx context.Context, diags diag.Diagnostics, o *dtoUserConfig) *tfoUserConfig {
	additionalBackupRegionsVar, d := types.SetValueFrom(ctx, types.StringType, o.AdditionalBackupRegions)
	diags.Append(d...)
	if diags.HasError() {
		return nil
	}
	authAzureadVar := schemautil.FlattenSetBlockNested(ctx, diags, flattenAuthAzuread, o.AuthAzuread, authAzureadAttrs)
	if diags.HasError() {
		return nil
	}
	authGenericOauthVar := schemautil.FlattenSetBlockNested(ctx, diags, flattenAuthGenericOauth, o.AuthGenericOauth, authGenericOauthAttrs)
	if diags.HasError() {
		return nil
	}
	authGithubVar := schemautil.FlattenSetBlockNested(ctx, diags, flattenAuthGithub, o.AuthGithub, authGithubAttrs)
	if diags.HasError() {
		return nil
	}
	authGitlabVar := schemautil.FlattenSetBlockNested(ctx, diags, flattenAuthGitlab, o.AuthGitlab, authGitlabAttrs)
	if diags.HasError() {
		return nil
	}
	authGoogleVar := schemautil.FlattenSetBlockNested(ctx, diags, flattenAuthGoogle, o.AuthGoogle, authGoogleAttrs)
	if diags.HasError() {
		return nil
	}
	dateFormatsVar := schemautil.FlattenSetBlockNested(ctx, diags, flattenDateFormats, o.DateFormats, dateFormatsAttrs)
	if diags.HasError() {
		return nil
	}
	externalImageStorageVar := schemautil.FlattenSetBlockNested(ctx, diags, flattenExternalImageStorage, o.ExternalImageStorage, externalImageStorageAttrs)
	if diags.HasError() {
		return nil
	}
	ipFilterVar := schemautil.FlattenSetNested(ctx, diags, flattenIpFilter, o.IpFilter, ipFilterAttrs)
	if diags.HasError() {
		return nil
	}
	privateAccessVar := schemautil.FlattenSetBlockNested(ctx, diags, flattenPrivateAccess, o.PrivateAccess, privateAccessAttrs)
	if diags.HasError() {
		return nil
	}
	privatelinkAccessVar := schemautil.FlattenSetBlockNested(ctx, diags, flattenPrivatelinkAccess, o.PrivatelinkAccess, privatelinkAccessAttrs)
	if diags.HasError() {
		return nil
	}
	publicAccessVar := schemautil.FlattenSetBlockNested(ctx, diags, flattenPublicAccess, o.PublicAccess, publicAccessAttrs)
	if diags.HasError() {
		return nil
	}
	smtpServerVar := schemautil.FlattenSetBlockNested(ctx, diags, flattenSmtpServer, o.SmtpServer, smtpServerAttrs)
	if diags.HasError() {
		return nil
	}
	return &tfoUserConfig{
		AdditionalBackupRegions:       additionalBackupRegionsVar,
		AlertingEnabled:               types.BoolPointerValue(o.AlertingEnabled),
		AlertingErrorOrTimeout:        types.StringPointerValue(o.AlertingErrorOrTimeout),
		AlertingMaxAnnotationsToKeep:  types.Int64PointerValue(o.AlertingMaxAnnotationsToKeep),
		AlertingNodataOrNullvalues:    types.StringPointerValue(o.AlertingNodataOrNullvalues),
		AllowEmbedding:                types.BoolPointerValue(o.AllowEmbedding),
		AuthAzuread:                   authAzureadVar,
		AuthBasicEnabled:              types.BoolPointerValue(o.AuthBasicEnabled),
		AuthGenericOauth:              authGenericOauthVar,
		AuthGithub:                    authGithubVar,
		AuthGitlab:                    authGitlabVar,
		AuthGoogle:                    authGoogleVar,
		CookieSamesite:                types.StringPointerValue(o.CookieSamesite),
		CustomDomain:                  types.StringPointerValue(o.CustomDomain),
		DashboardPreviewsEnabled:      types.BoolPointerValue(o.DashboardPreviewsEnabled),
		DashboardsMinRefreshInterval:  types.StringPointerValue(o.DashboardsMinRefreshInterval),
		DashboardsVersionsToKeep:      types.Int64PointerValue(o.DashboardsVersionsToKeep),
		DataproxySendUserHeader:       types.BoolPointerValue(o.DataproxySendUserHeader),
		DataproxyTimeout:              types.Int64PointerValue(o.DataproxyTimeout),
		DateFormats:                   dateFormatsVar,
		DisableGravatar:               types.BoolPointerValue(o.DisableGravatar),
		EditorsCanAdmin:               types.BoolPointerValue(o.EditorsCanAdmin),
		ExternalImageStorage:          externalImageStorageVar,
		GoogleAnalyticsUaId:           types.StringPointerValue(o.GoogleAnalyticsUaId),
		IpFilter:                      ipFilterVar,
		MetricsEnabled:                types.BoolPointerValue(o.MetricsEnabled),
		OauthAllowInsecureEmailLookup: types.BoolPointerValue(o.OauthAllowInsecureEmailLookup),
		PrivateAccess:                 privateAccessVar,
		PrivatelinkAccess:             privatelinkAccessVar,
		ProjectToForkFrom:             types.StringPointerValue(o.ProjectToForkFrom),
		PublicAccess:                  publicAccessVar,
		RecoveryBasebackupName:        types.StringPointerValue(o.RecoveryBasebackupName),
		ServiceToForkFrom:             types.StringPointerValue(o.ServiceToForkFrom),
		SmtpServer:                    smtpServerVar,
		StaticIps:                     types.BoolPointerValue(o.StaticIps),
		UnifiedAlertingEnabled:        types.BoolPointerValue(o.UnifiedAlertingEnabled),
		UserAutoAssignOrg:             types.BoolPointerValue(o.UserAutoAssignOrg),
		UserAutoAssignOrgRole:         types.StringPointerValue(o.UserAutoAssignOrgRole),
		ViewersCanEdit:                types.BoolPointerValue(o.ViewersCanEdit),
	}
}

var userConfigAttrs = map[string]attr.Type{
	"additional_backup_regions":         types.SetType{ElemType: types.StringType},
	"alerting_enabled":                  types.BoolType,
	"alerting_error_or_timeout":         types.StringType,
	"alerting_max_annotations_to_keep":  types.Int64Type,
	"alerting_nodata_or_nullvalues":     types.StringType,
	"allow_embedding":                   types.BoolType,
	"auth_azuread":                      types.SetType{ElemType: types.ObjectType{AttrTypes: authAzureadAttrs}},
	"auth_basic_enabled":                types.BoolType,
	"auth_generic_oauth":                types.SetType{ElemType: types.ObjectType{AttrTypes: authGenericOauthAttrs}},
	"auth_github":                       types.SetType{ElemType: types.ObjectType{AttrTypes: authGithubAttrs}},
	"auth_gitlab":                       types.SetType{ElemType: types.ObjectType{AttrTypes: authGitlabAttrs}},
	"auth_google":                       types.SetType{ElemType: types.ObjectType{AttrTypes: authGoogleAttrs}},
	"cookie_samesite":                   types.StringType,
	"custom_domain":                     types.StringType,
	"dashboard_previews_enabled":        types.BoolType,
	"dashboards_min_refresh_interval":   types.StringType,
	"dashboards_versions_to_keep":       types.Int64Type,
	"dataproxy_send_user_header":        types.BoolType,
	"dataproxy_timeout":                 types.Int64Type,
	"date_formats":                      types.SetType{ElemType: types.ObjectType{AttrTypes: dateFormatsAttrs}},
	"disable_gravatar":                  types.BoolType,
	"editors_can_admin":                 types.BoolType,
	"external_image_storage":            types.SetType{ElemType: types.ObjectType{AttrTypes: externalImageStorageAttrs}},
	"google_analytics_ua_id":            types.StringType,
	"ip_filter":                         types.SetType{ElemType: types.ObjectType{AttrTypes: ipFilterAttrs}},
	"metrics_enabled":                   types.BoolType,
	"oauth_allow_insecure_email_lookup": types.BoolType,
	"private_access":                    types.SetType{ElemType: types.ObjectType{AttrTypes: privateAccessAttrs}},
	"privatelink_access":                types.SetType{ElemType: types.ObjectType{AttrTypes: privatelinkAccessAttrs}},
	"project_to_fork_from":              types.StringType,
	"public_access":                     types.SetType{ElemType: types.ObjectType{AttrTypes: publicAccessAttrs}},
	"recovery_basebackup_name":          types.StringType,
	"service_to_fork_from":              types.StringType,
	"smtp_server":                       types.SetType{ElemType: types.ObjectType{AttrTypes: smtpServerAttrs}},
	"static_ips":                        types.BoolType,
	"unified_alerting_enabled":          types.BoolType,
	"user_auto_assign_org":              types.BoolType,
	"user_auto_assign_org_role":         types.StringType,
	"viewers_can_edit":                  types.BoolType,
}

// tfoAuthAzuread Azure AD OAuth integration
type tfoAuthAzuread struct {
	AllowSignUp    types.Bool   `tfsdk:"allow_sign_up"`
	AllowedDomains types.Set    `tfsdk:"allowed_domains"`
	AllowedGroups  types.Set    `tfsdk:"allowed_groups"`
	AuthUrl        types.String `tfsdk:"auth_url"`
	ClientId       types.String `tfsdk:"client_id"`
	ClientSecret   types.String `tfsdk:"client_secret"`
	TokenUrl       types.String `tfsdk:"token_url"`
}

// dtoAuthAzuread request/response object
type dtoAuthAzuread struct {
	AllowSignUp    *bool    `groups:"create,update" json:"allow_sign_up,omitempty"`
	AllowedDomains []string `groups:"create,update" json:"allowed_domains,omitempty"`
	AllowedGroups  []string `groups:"create,update" json:"allowed_groups,omitempty"`
	AuthUrl        string   `groups:"create,update" json:"auth_url"`
	ClientId       string   `groups:"create,update" json:"client_id"`
	ClientSecret   string   `groups:"create,update" json:"client_secret"`
	TokenUrl       string   `groups:"create,update" json:"token_url"`
}

// expandAuthAzuread expands tf object into dto object
func expandAuthAzuread(ctx context.Context, diags diag.Diagnostics, o *tfoAuthAzuread) *dtoAuthAzuread {
	allowedDomainsVar := schemautil.ExpandSet[string](ctx, diags, o.AllowedDomains)
	if diags.HasError() {
		return nil
	}
	allowedGroupsVar := schemautil.ExpandSet[string](ctx, diags, o.AllowedGroups)
	if diags.HasError() {
		return nil
	}
	return &dtoAuthAzuread{
		AllowSignUp:    schemautil.ValueBoolPointer(o.AllowSignUp),
		AllowedDomains: allowedDomainsVar,
		AllowedGroups:  allowedGroupsVar,
		AuthUrl:        o.AuthUrl.ValueString(),
		ClientId:       o.ClientId.ValueString(),
		ClientSecret:   o.ClientSecret.ValueString(),
		TokenUrl:       o.TokenUrl.ValueString(),
	}
}

// flattenAuthAzuread flattens dto object into tf object
func flattenAuthAzuread(ctx context.Context, diags diag.Diagnostics, o *dtoAuthAzuread) *tfoAuthAzuread {
	allowedDomainsVar, d := types.SetValueFrom(ctx, types.StringType, o.AllowedDomains)
	diags.Append(d...)
	if diags.HasError() {
		return nil
	}
	allowedGroupsVar, d := types.SetValueFrom(ctx, types.StringType, o.AllowedGroups)
	diags.Append(d...)
	if diags.HasError() {
		return nil
	}
	return &tfoAuthAzuread{
		AllowSignUp:    types.BoolPointerValue(o.AllowSignUp),
		AllowedDomains: allowedDomainsVar,
		AllowedGroups:  allowedGroupsVar,
		AuthUrl:        types.StringValue(o.AuthUrl),
		ClientId:       types.StringValue(o.ClientId),
		ClientSecret:   types.StringValue(o.ClientSecret),
		TokenUrl:       types.StringValue(o.TokenUrl),
	}
}

var authAzureadAttrs = map[string]attr.Type{
	"allow_sign_up":   types.BoolType,
	"allowed_domains": types.SetType{ElemType: types.StringType},
	"allowed_groups":  types.SetType{ElemType: types.StringType},
	"auth_url":        types.StringType,
	"client_id":       types.StringType,
	"client_secret":   types.StringType,
	"token_url":       types.StringType,
}

// tfoAuthGenericOauth Generic OAuth integration
type tfoAuthGenericOauth struct {
	AllowSignUp          types.Bool   `tfsdk:"allow_sign_up"`
	AllowedDomains       types.Set    `tfsdk:"allowed_domains"`
	AllowedOrganizations types.Set    `tfsdk:"allowed_organizations"`
	ApiUrl               types.String `tfsdk:"api_url"`
	AuthUrl              types.String `tfsdk:"auth_url"`
	AutoLogin            types.Bool   `tfsdk:"auto_login"`
	ClientId             types.String `tfsdk:"client_id"`
	ClientSecret         types.String `tfsdk:"client_secret"`
	Name                 types.String `tfsdk:"name"`
	Scopes               types.Set    `tfsdk:"scopes"`
	TokenUrl             types.String `tfsdk:"token_url"`
}

// dtoAuthGenericOauth request/response object
type dtoAuthGenericOauth struct {
	AllowSignUp          *bool    `groups:"create,update" json:"allow_sign_up,omitempty"`
	AllowedDomains       []string `groups:"create,update" json:"allowed_domains,omitempty"`
	AllowedOrganizations []string `groups:"create,update" json:"allowed_organizations,omitempty"`
	ApiUrl               string   `groups:"create,update" json:"api_url"`
	AuthUrl              string   `groups:"create,update" json:"auth_url"`
	AutoLogin            *bool    `groups:"create,update" json:"auto_login,omitempty"`
	ClientId             string   `groups:"create,update" json:"client_id"`
	ClientSecret         string   `groups:"create,update" json:"client_secret"`
	Name                 *string  `groups:"create,update" json:"name,omitempty"`
	Scopes               []string `groups:"create,update" json:"scopes,omitempty"`
	TokenUrl             string   `groups:"create,update" json:"token_url"`
}

// expandAuthGenericOauth expands tf object into dto object
func expandAuthGenericOauth(ctx context.Context, diags diag.Diagnostics, o *tfoAuthGenericOauth) *dtoAuthGenericOauth {
	allowedDomainsVar := schemautil.ExpandSet[string](ctx, diags, o.AllowedDomains)
	if diags.HasError() {
		return nil
	}
	allowedOrganizationsVar := schemautil.ExpandSet[string](ctx, diags, o.AllowedOrganizations)
	if diags.HasError() {
		return nil
	}
	scopesVar := schemautil.ExpandSet[string](ctx, diags, o.Scopes)
	if diags.HasError() {
		return nil
	}
	return &dtoAuthGenericOauth{
		AllowSignUp:          schemautil.ValueBoolPointer(o.AllowSignUp),
		AllowedDomains:       allowedDomainsVar,
		AllowedOrganizations: allowedOrganizationsVar,
		ApiUrl:               o.ApiUrl.ValueString(),
		AuthUrl:              o.AuthUrl.ValueString(),
		AutoLogin:            schemautil.ValueBoolPointer(o.AutoLogin),
		ClientId:             o.ClientId.ValueString(),
		ClientSecret:         o.ClientSecret.ValueString(),
		Name:                 schemautil.ValueStringPointer(o.Name),
		Scopes:               scopesVar,
		TokenUrl:             o.TokenUrl.ValueString(),
	}
}

// flattenAuthGenericOauth flattens dto object into tf object
func flattenAuthGenericOauth(ctx context.Context, diags diag.Diagnostics, o *dtoAuthGenericOauth) *tfoAuthGenericOauth {
	allowedDomainsVar, d := types.SetValueFrom(ctx, types.StringType, o.AllowedDomains)
	diags.Append(d...)
	if diags.HasError() {
		return nil
	}
	allowedOrganizationsVar, d := types.SetValueFrom(ctx, types.StringType, o.AllowedOrganizations)
	diags.Append(d...)
	if diags.HasError() {
		return nil
	}
	scopesVar, d := types.SetValueFrom(ctx, types.StringType, o.Scopes)
	diags.Append(d...)
	if diags.HasError() {
		return nil
	}
	return &tfoAuthGenericOauth{
		AllowSignUp:          types.BoolPointerValue(o.AllowSignUp),
		AllowedDomains:       allowedDomainsVar,
		AllowedOrganizations: allowedOrganizationsVar,
		ApiUrl:               types.StringValue(o.ApiUrl),
		AuthUrl:              types.StringValue(o.AuthUrl),
		AutoLogin:            types.BoolPointerValue(o.AutoLogin),
		ClientId:             types.StringValue(o.ClientId),
		ClientSecret:         types.StringValue(o.ClientSecret),
		Name:                 types.StringPointerValue(o.Name),
		Scopes:               scopesVar,
		TokenUrl:             types.StringValue(o.TokenUrl),
	}
}

var authGenericOauthAttrs = map[string]attr.Type{
	"allow_sign_up":         types.BoolType,
	"allowed_domains":       types.SetType{ElemType: types.StringType},
	"allowed_organizations": types.SetType{ElemType: types.StringType},
	"api_url":               types.StringType,
	"auth_url":              types.StringType,
	"auto_login":            types.BoolType,
	"client_id":             types.StringType,
	"client_secret":         types.StringType,
	"name":                  types.StringType,
	"scopes":                types.SetType{ElemType: types.StringType},
	"token_url":             types.StringType,
}

// tfoAuthGithub Github Auth integration
type tfoAuthGithub struct {
	AllowSignUp          types.Bool   `tfsdk:"allow_sign_up"`
	AllowedOrganizations types.Set    `tfsdk:"allowed_organizations"`
	ClientId             types.String `tfsdk:"client_id"`
	ClientSecret         types.String `tfsdk:"client_secret"`
	TeamIds              types.Set    `tfsdk:"team_ids"`
}

// dtoAuthGithub request/response object
type dtoAuthGithub struct {
	AllowSignUp          *bool    `groups:"create,update" json:"allow_sign_up,omitempty"`
	AllowedOrganizations []string `groups:"create,update" json:"allowed_organizations,omitempty"`
	ClientId             string   `groups:"create,update" json:"client_id"`
	ClientSecret         string   `groups:"create,update" json:"client_secret"`
	TeamIds              []int64  `groups:"create,update" json:"team_ids,omitempty"`
}

// expandAuthGithub expands tf object into dto object
func expandAuthGithub(ctx context.Context, diags diag.Diagnostics, o *tfoAuthGithub) *dtoAuthGithub {
	allowedOrganizationsVar := schemautil.ExpandSet[string](ctx, diags, o.AllowedOrganizations)
	if diags.HasError() {
		return nil
	}
	teamIdsVar := schemautil.ExpandSet[int64](ctx, diags, o.TeamIds)
	if diags.HasError() {
		return nil
	}
	return &dtoAuthGithub{
		AllowSignUp:          schemautil.ValueBoolPointer(o.AllowSignUp),
		AllowedOrganizations: allowedOrganizationsVar,
		ClientId:             o.ClientId.ValueString(),
		ClientSecret:         o.ClientSecret.ValueString(),
		TeamIds:              teamIdsVar,
	}
}

// flattenAuthGithub flattens dto object into tf object
func flattenAuthGithub(ctx context.Context, diags diag.Diagnostics, o *dtoAuthGithub) *tfoAuthGithub {
	allowedOrganizationsVar, d := types.SetValueFrom(ctx, types.StringType, o.AllowedOrganizations)
	diags.Append(d...)
	if diags.HasError() {
		return nil
	}
	teamIdsVar, d := types.SetValueFrom(ctx, types.Int64Type, o.TeamIds)
	diags.Append(d...)
	if diags.HasError() {
		return nil
	}
	return &tfoAuthGithub{
		AllowSignUp:          types.BoolPointerValue(o.AllowSignUp),
		AllowedOrganizations: allowedOrganizationsVar,
		ClientId:             types.StringValue(o.ClientId),
		ClientSecret:         types.StringValue(o.ClientSecret),
		TeamIds:              teamIdsVar,
	}
}

var authGithubAttrs = map[string]attr.Type{
	"allow_sign_up":         types.BoolType,
	"allowed_organizations": types.SetType{ElemType: types.StringType},
	"client_id":             types.StringType,
	"client_secret":         types.StringType,
	"team_ids":              types.SetType{ElemType: types.Int64Type},
}

// tfoAuthGitlab GitLab Auth integration
type tfoAuthGitlab struct {
	AllowSignUp   types.Bool   `tfsdk:"allow_sign_up"`
	AllowedGroups types.Set    `tfsdk:"allowed_groups"`
	ApiUrl        types.String `tfsdk:"api_url"`
	AuthUrl       types.String `tfsdk:"auth_url"`
	ClientId      types.String `tfsdk:"client_id"`
	ClientSecret  types.String `tfsdk:"client_secret"`
	TokenUrl      types.String `tfsdk:"token_url"`
}

// dtoAuthGitlab request/response object
type dtoAuthGitlab struct {
	AllowSignUp   *bool    `groups:"create,update" json:"allow_sign_up,omitempty"`
	AllowedGroups []string `groups:"create,update" json:"allowed_groups"`
	ApiUrl        *string  `groups:"create,update" json:"api_url,omitempty"`
	AuthUrl       *string  `groups:"create,update" json:"auth_url,omitempty"`
	ClientId      string   `groups:"create,update" json:"client_id"`
	ClientSecret  string   `groups:"create,update" json:"client_secret"`
	TokenUrl      *string  `groups:"create,update" json:"token_url,omitempty"`
}

// expandAuthGitlab expands tf object into dto object
func expandAuthGitlab(ctx context.Context, diags diag.Diagnostics, o *tfoAuthGitlab) *dtoAuthGitlab {
	allowedGroupsVar := schemautil.ExpandSet[string](ctx, diags, o.AllowedGroups)
	if diags.HasError() {
		return nil
	}
	return &dtoAuthGitlab{
		AllowSignUp:   schemautil.ValueBoolPointer(o.AllowSignUp),
		AllowedGroups: allowedGroupsVar,
		ApiUrl:        schemautil.ValueStringPointer(o.ApiUrl),
		AuthUrl:       schemautil.ValueStringPointer(o.AuthUrl),
		ClientId:      o.ClientId.ValueString(),
		ClientSecret:  o.ClientSecret.ValueString(),
		TokenUrl:      schemautil.ValueStringPointer(o.TokenUrl),
	}
}

// flattenAuthGitlab flattens dto object into tf object
func flattenAuthGitlab(ctx context.Context, diags diag.Diagnostics, o *dtoAuthGitlab) *tfoAuthGitlab {
	allowedGroupsVar, d := types.SetValueFrom(ctx, types.StringType, o.AllowedGroups)
	diags.Append(d...)
	if diags.HasError() {
		return nil
	}
	return &tfoAuthGitlab{
		AllowSignUp:   types.BoolPointerValue(o.AllowSignUp),
		AllowedGroups: allowedGroupsVar,
		ApiUrl:        types.StringPointerValue(o.ApiUrl),
		AuthUrl:       types.StringPointerValue(o.AuthUrl),
		ClientId:      types.StringValue(o.ClientId),
		ClientSecret:  types.StringValue(o.ClientSecret),
		TokenUrl:      types.StringPointerValue(o.TokenUrl),
	}
}

var authGitlabAttrs = map[string]attr.Type{
	"allow_sign_up":  types.BoolType,
	"allowed_groups": types.SetType{ElemType: types.StringType},
	"api_url":        types.StringType,
	"auth_url":       types.StringType,
	"client_id":      types.StringType,
	"client_secret":  types.StringType,
	"token_url":      types.StringType,
}

// tfoAuthGoogle Google Auth integration
type tfoAuthGoogle struct {
	AllowSignUp    types.Bool   `tfsdk:"allow_sign_up"`
	AllowedDomains types.Set    `tfsdk:"allowed_domains"`
	ClientId       types.String `tfsdk:"client_id"`
	ClientSecret   types.String `tfsdk:"client_secret"`
}

// dtoAuthGoogle request/response object
type dtoAuthGoogle struct {
	AllowSignUp    *bool    `groups:"create,update" json:"allow_sign_up,omitempty"`
	AllowedDomains []string `groups:"create,update" json:"allowed_domains"`
	ClientId       string   `groups:"create,update" json:"client_id"`
	ClientSecret   string   `groups:"create,update" json:"client_secret"`
}

// expandAuthGoogle expands tf object into dto object
func expandAuthGoogle(ctx context.Context, diags diag.Diagnostics, o *tfoAuthGoogle) *dtoAuthGoogle {
	allowedDomainsVar := schemautil.ExpandSet[string](ctx, diags, o.AllowedDomains)
	if diags.HasError() {
		return nil
	}
	return &dtoAuthGoogle{
		AllowSignUp:    schemautil.ValueBoolPointer(o.AllowSignUp),
		AllowedDomains: allowedDomainsVar,
		ClientId:       o.ClientId.ValueString(),
		ClientSecret:   o.ClientSecret.ValueString(),
	}
}

// flattenAuthGoogle flattens dto object into tf object
func flattenAuthGoogle(ctx context.Context, diags diag.Diagnostics, o *dtoAuthGoogle) *tfoAuthGoogle {
	allowedDomainsVar, d := types.SetValueFrom(ctx, types.StringType, o.AllowedDomains)
	diags.Append(d...)
	if diags.HasError() {
		return nil
	}
	return &tfoAuthGoogle{
		AllowSignUp:    types.BoolPointerValue(o.AllowSignUp),
		AllowedDomains: allowedDomainsVar,
		ClientId:       types.StringValue(o.ClientId),
		ClientSecret:   types.StringValue(o.ClientSecret),
	}
}

var authGoogleAttrs = map[string]attr.Type{
	"allow_sign_up":   types.BoolType,
	"allowed_domains": types.SetType{ElemType: types.StringType},
	"client_id":       types.StringType,
	"client_secret":   types.StringType,
}

// tfoDateFormats Grafana date format specifications
type tfoDateFormats struct {
	DefaultTimezone types.String `tfsdk:"default_timezone"`
	FullDate        types.String `tfsdk:"full_date"`
	IntervalDay     types.String `tfsdk:"interval_day"`
	IntervalHour    types.String `tfsdk:"interval_hour"`
	IntervalMinute  types.String `tfsdk:"interval_minute"`
	IntervalMonth   types.String `tfsdk:"interval_month"`
	IntervalSecond  types.String `tfsdk:"interval_second"`
	IntervalYear    types.String `tfsdk:"interval_year"`
}

// dtoDateFormats request/response object
type dtoDateFormats struct {
	DefaultTimezone *string `groups:"create,update" json:"default_timezone,omitempty"`
	FullDate        *string `groups:"create,update" json:"full_date,omitempty"`
	IntervalDay     *string `groups:"create,update" json:"interval_day,omitempty"`
	IntervalHour    *string `groups:"create,update" json:"interval_hour,omitempty"`
	IntervalMinute  *string `groups:"create,update" json:"interval_minute,omitempty"`
	IntervalMonth   *string `groups:"create,update" json:"interval_month,omitempty"`
	IntervalSecond  *string `groups:"create,update" json:"interval_second,omitempty"`
	IntervalYear    *string `groups:"create,update" json:"interval_year,omitempty"`
}

// expandDateFormats expands tf object into dto object
func expandDateFormats(ctx context.Context, diags diag.Diagnostics, o *tfoDateFormats) *dtoDateFormats {
	return &dtoDateFormats{
		DefaultTimezone: schemautil.ValueStringPointer(o.DefaultTimezone),
		FullDate:        schemautil.ValueStringPointer(o.FullDate),
		IntervalDay:     schemautil.ValueStringPointer(o.IntervalDay),
		IntervalHour:    schemautil.ValueStringPointer(o.IntervalHour),
		IntervalMinute:  schemautil.ValueStringPointer(o.IntervalMinute),
		IntervalMonth:   schemautil.ValueStringPointer(o.IntervalMonth),
		IntervalSecond:  schemautil.ValueStringPointer(o.IntervalSecond),
		IntervalYear:    schemautil.ValueStringPointer(o.IntervalYear),
	}
}

// flattenDateFormats flattens dto object into tf object
func flattenDateFormats(ctx context.Context, diags diag.Diagnostics, o *dtoDateFormats) *tfoDateFormats {
	return &tfoDateFormats{
		DefaultTimezone: types.StringPointerValue(o.DefaultTimezone),
		FullDate:        types.StringPointerValue(o.FullDate),
		IntervalDay:     types.StringPointerValue(o.IntervalDay),
		IntervalHour:    types.StringPointerValue(o.IntervalHour),
		IntervalMinute:  types.StringPointerValue(o.IntervalMinute),
		IntervalMonth:   types.StringPointerValue(o.IntervalMonth),
		IntervalSecond:  types.StringPointerValue(o.IntervalSecond),
		IntervalYear:    types.StringPointerValue(o.IntervalYear),
	}
}

var dateFormatsAttrs = map[string]attr.Type{
	"default_timezone": types.StringType,
	"full_date":        types.StringType,
	"interval_day":     types.StringType,
	"interval_hour":    types.StringType,
	"interval_minute":  types.StringType,
	"interval_month":   types.StringType,
	"interval_second":  types.StringType,
	"interval_year":    types.StringType,
}

// tfoExternalImageStorage External image store settings
type tfoExternalImageStorage struct {
	AccessKey types.String `tfsdk:"access_key"`
	BucketUrl types.String `tfsdk:"bucket_url"`
	Provider  types.String `tfsdk:"provider"`
	SecretKey types.String `tfsdk:"secret_key"`
}

// dtoExternalImageStorage request/response object
type dtoExternalImageStorage struct {
	AccessKey string `groups:"create,update" json:"access_key"`
	BucketUrl string `groups:"create,update" json:"bucket_url"`
	Provider  string `groups:"create,update" json:"provider"`
	SecretKey string `groups:"create,update" json:"secret_key"`
}

// expandExternalImageStorage expands tf object into dto object
func expandExternalImageStorage(ctx context.Context, diags diag.Diagnostics, o *tfoExternalImageStorage) *dtoExternalImageStorage {
	return &dtoExternalImageStorage{
		AccessKey: o.AccessKey.ValueString(),
		BucketUrl: o.BucketUrl.ValueString(),
		Provider:  o.Provider.ValueString(),
		SecretKey: o.SecretKey.ValueString(),
	}
}

// flattenExternalImageStorage flattens dto object into tf object
func flattenExternalImageStorage(ctx context.Context, diags diag.Diagnostics, o *dtoExternalImageStorage) *tfoExternalImageStorage {
	return &tfoExternalImageStorage{
		AccessKey: types.StringValue(o.AccessKey),
		BucketUrl: types.StringValue(o.BucketUrl),
		Provider:  types.StringValue(o.Provider),
		SecretKey: types.StringValue(o.SecretKey),
	}
}

var externalImageStorageAttrs = map[string]attr.Type{
	"access_key": types.StringType,
	"bucket_url": types.StringType,
	"provider":   types.StringType,
	"secret_key": types.StringType,
}

// tfoIpFilter CIDR address block, either as a string, or in a dict with an optional description field
type tfoIpFilter struct {
	Description types.String `tfsdk:"description"`
	Network     types.String `tfsdk:"network"`
}

// dtoIpFilter request/response object
type dtoIpFilter struct {
	Description *string `groups:"create,update" json:"description,omitempty"`
	Network     string  `groups:"create,update" json:"network"`
}

func (d *dtoIpFilter) UnmarshalJSON(data []byte) error {
	var s string
	err := json.Unmarshal(data, &s)
	if err == nil {
		d.Network = s
		return nil
	}

	type obj dtoIpFilter
	o := &struct {
		Description *string `groups:"create,update" json:"description,omitempty"`
		Network     string  `groups:"create,update" json:"network"`
	}{}
	err = json.Unmarshal(data, o)
	if err != nil {
		return err
	}

	d.Description = o.Description
	d.Network = o.Network
	return nil
}

// expandIpFilter expands tf object into dto object
func expandIpFilter(ctx context.Context, diags diag.Diagnostics, o *tfoIpFilter) *dtoIpFilter {
	return &dtoIpFilter{
		Description: schemautil.ValueStringPointer(o.Description),
		Network:     o.Network.ValueString(),
	}
}

// flattenIpFilter flattens dto object into tf object
func flattenIpFilter(ctx context.Context, diags diag.Diagnostics, o *dtoIpFilter) *tfoIpFilter {
	return &tfoIpFilter{
		Description: types.StringPointerValue(o.Description),
		Network:     types.StringValue(o.Network),
	}
}

var ipFilterAttrs = map[string]attr.Type{
	"description": types.StringType,
	"network":     types.StringType,
}

// tfoPrivateAccess Allow access to selected service ports from private networks
type tfoPrivateAccess struct {
	Grafana types.Bool `tfsdk:"grafana"`
}

// dtoPrivateAccess request/response object
type dtoPrivateAccess struct {
	Grafana *bool `groups:"create,update" json:"grafana,omitempty"`
}

// expandPrivateAccess expands tf object into dto object
func expandPrivateAccess(ctx context.Context, diags diag.Diagnostics, o *tfoPrivateAccess) *dtoPrivateAccess {
	return &dtoPrivateAccess{Grafana: schemautil.ValueBoolPointer(o.Grafana)}
}

// flattenPrivateAccess flattens dto object into tf object
func flattenPrivateAccess(ctx context.Context, diags diag.Diagnostics, o *dtoPrivateAccess) *tfoPrivateAccess {
	return &tfoPrivateAccess{Grafana: types.BoolPointerValue(o.Grafana)}
}

var privateAccessAttrs = map[string]attr.Type{"grafana": types.BoolType}

// tfoPrivatelinkAccess Allow access to selected service components through Privatelink
type tfoPrivatelinkAccess struct {
	Grafana types.Bool `tfsdk:"grafana"`
}

// dtoPrivatelinkAccess request/response object
type dtoPrivatelinkAccess struct {
	Grafana *bool `groups:"create,update" json:"grafana,omitempty"`
}

// expandPrivatelinkAccess expands tf object into dto object
func expandPrivatelinkAccess(ctx context.Context, diags diag.Diagnostics, o *tfoPrivatelinkAccess) *dtoPrivatelinkAccess {
	return &dtoPrivatelinkAccess{Grafana: schemautil.ValueBoolPointer(o.Grafana)}
}

// flattenPrivatelinkAccess flattens dto object into tf object
func flattenPrivatelinkAccess(ctx context.Context, diags diag.Diagnostics, o *dtoPrivatelinkAccess) *tfoPrivatelinkAccess {
	return &tfoPrivatelinkAccess{Grafana: types.BoolPointerValue(o.Grafana)}
}

var privatelinkAccessAttrs = map[string]attr.Type{"grafana": types.BoolType}

// tfoPublicAccess Allow access to selected service ports from the public Internet
type tfoPublicAccess struct {
	Grafana types.Bool `tfsdk:"grafana"`
}

// dtoPublicAccess request/response object
type dtoPublicAccess struct {
	Grafana *bool `groups:"create,update" json:"grafana,omitempty"`
}

// expandPublicAccess expands tf object into dto object
func expandPublicAccess(ctx context.Context, diags diag.Diagnostics, o *tfoPublicAccess) *dtoPublicAccess {
	return &dtoPublicAccess{Grafana: schemautil.ValueBoolPointer(o.Grafana)}
}

// flattenPublicAccess flattens dto object into tf object
func flattenPublicAccess(ctx context.Context, diags diag.Diagnostics, o *dtoPublicAccess) *tfoPublicAccess {
	return &tfoPublicAccess{Grafana: types.BoolPointerValue(o.Grafana)}
}

var publicAccessAttrs = map[string]attr.Type{"grafana": types.BoolType}

// tfoSmtpServer SMTP server settings
type tfoSmtpServer struct {
	FromAddress    types.String `tfsdk:"from_address"`
	FromName       types.String `tfsdk:"from_name"`
	Host           types.String `tfsdk:"host"`
	Password       types.String `tfsdk:"password"`
	Port           types.Int64  `tfsdk:"port"`
	SkipVerify     types.Bool   `tfsdk:"skip_verify"`
	StarttlsPolicy types.String `tfsdk:"starttls_policy"`
	Username       types.String `tfsdk:"username"`
}

// dtoSmtpServer request/response object
type dtoSmtpServer struct {
	FromAddress    string  `groups:"create,update" json:"from_address"`
	FromName       *string `groups:"create,update" json:"from_name,omitempty"`
	Host           string  `groups:"create,update" json:"host"`
	Password       *string `groups:"create,update" json:"password,omitempty"`
	Port           int64   `groups:"create,update" json:"port"`
	SkipVerify     *bool   `groups:"create,update" json:"skip_verify,omitempty"`
	StarttlsPolicy *string `groups:"create,update" json:"starttls_policy,omitempty"`
	Username       *string `groups:"create,update" json:"username,omitempty"`
}

// expandSmtpServer expands tf object into dto object
func expandSmtpServer(ctx context.Context, diags diag.Diagnostics, o *tfoSmtpServer) *dtoSmtpServer {
	return &dtoSmtpServer{
		FromAddress:    o.FromAddress.ValueString(),
		FromName:       schemautil.ValueStringPointer(o.FromName),
		Host:           o.Host.ValueString(),
		Password:       schemautil.ValueStringPointer(o.Password),
		Port:           o.Port.ValueInt64(),
		SkipVerify:     schemautil.ValueBoolPointer(o.SkipVerify),
		StarttlsPolicy: schemautil.ValueStringPointer(o.StarttlsPolicy),
		Username:       schemautil.ValueStringPointer(o.Username),
	}
}

// flattenSmtpServer flattens dto object into tf object
func flattenSmtpServer(ctx context.Context, diags diag.Diagnostics, o *dtoSmtpServer) *tfoSmtpServer {
	return &tfoSmtpServer{
		FromAddress:    types.StringValue(o.FromAddress),
		FromName:       types.StringPointerValue(o.FromName),
		Host:           types.StringValue(o.Host),
		Password:       types.StringPointerValue(o.Password),
		Port:           types.Int64Value(o.Port),
		SkipVerify:     types.BoolPointerValue(o.SkipVerify),
		StarttlsPolicy: types.StringPointerValue(o.StarttlsPolicy),
		Username:       types.StringPointerValue(o.Username),
	}
}

var smtpServerAttrs = map[string]attr.Type{
	"from_address":    types.StringType,
	"from_name":       types.StringType,
	"host":            types.StringType,
	"password":        types.StringType,
	"port":            types.Int64Type,
	"skip_verify":     types.BoolType,
	"starttls_policy": types.StringType,
	"username":        types.StringType,
}

// Expand public function that converts tf object into dto
func Expand(ctx context.Context, diags diag.Diagnostics, set types.Set) *dtoUserConfig {
	return schemautil.ExpandSetBlockNested[tfoUserConfig, dtoUserConfig](ctx, diags, expandUserConfig, set)
}

// Flatten public function that converts dto into tf object
func Flatten(ctx context.Context, diags diag.Diagnostics, m map[string]any) types.Set {
	o := new(dtoUserConfig)
	err := schemautil.MapToDTO(m, o)
	if err != nil {
		diags.AddError("Failed to marshal map user config to dto", err.Error())
		return types.SetNull(types.ObjectType{AttrTypes: userConfigAttrs})
	}
	return schemautil.FlattenSetBlockNested[dtoUserConfig, tfoUserConfig](ctx, diags, flattenUserConfig, o, userConfigAttrs)
}
