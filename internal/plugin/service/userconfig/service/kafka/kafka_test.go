// Code generated by user config generator. DO NOT EDIT.

package kafka

import (
	"context"
	"encoding/json"
	"testing"

	"github.com/google/go-cmp/cmp"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/stretchr/testify/require"

	"github.com/aiven/terraform-provider-aiven/internal/schemautil"
)

const allFields = `{
    "additional_backup_regions": [
        "foo"
    ],
    "custom_domain": "foo",
    "ip_filter": [
        {
            "description": "foo",
            "network": "foo"
        }
    ],
    "kafka": {
        "auto_create_topics_enable": true,
        "compression_type": "foo",
        "connections_max_idle_ms": 1,
        "default_replication_factor": 1,
        "group_initial_rebalance_delay_ms": 1,
        "group_max_session_timeout_ms": 1,
        "group_min_session_timeout_ms": 1,
        "log_cleaner_delete_retention_ms": 1,
        "log_cleaner_max_compaction_lag_ms": 1,
        "log_cleaner_min_cleanable_ratio": 1,
        "log_cleaner_min_compaction_lag_ms": 1,
        "log_cleanup_policy": "foo",
        "log_flush_interval_messages": 1,
        "log_flush_interval_ms": 1,
        "log_index_interval_bytes": 1,
        "log_index_size_max_bytes": 1,
        "log_local_retention_bytes": 1,
        "log_local_retention_ms": 1,
        "log_message_downconversion_enable": true,
        "log_message_timestamp_difference_max_ms": 1,
        "log_message_timestamp_type": "foo",
        "log_preallocate": true,
        "log_retention_bytes": 1,
        "log_retention_hours": 1,
        "log_retention_ms": 1,
        "log_roll_jitter_ms": 1,
        "log_roll_ms": 1,
        "log_segment_bytes": 1,
        "log_segment_delete_delay_ms": 1,
        "max_connections_per_ip": 1,
        "max_incremental_fetch_session_cache_slots": 1,
        "message_max_bytes": 1,
        "min_insync_replicas": 1,
        "num_partitions": 1,
        "offsets_retention_minutes": 1,
        "producer_purgatory_purge_interval_requests": 1,
        "replica_fetch_max_bytes": 1,
        "replica_fetch_response_max_bytes": 1,
        "sasl_oauthbearer_expected_audience": "foo",
        "sasl_oauthbearer_expected_issuer": "foo",
        "sasl_oauthbearer_jwks_endpoint_url": "foo",
        "sasl_oauthbearer_sub_claim_name": "foo",
        "socket_request_max_bytes": 1,
        "transaction_remove_expired_transaction_cleanup_interval_ms": 1,
        "transaction_state_log_segment_bytes": 1
    },
    "kafka_authentication_methods": {
        "certificate": true,
        "sasl": true
    },
    "kafka_connect": true,
    "kafka_connect_config": {
        "connector_client_config_override_policy": "foo",
        "consumer_auto_offset_reset": "foo",
        "consumer_fetch_max_bytes": 1,
        "consumer_isolation_level": "foo",
        "consumer_max_partition_fetch_bytes": 1,
        "consumer_max_poll_interval_ms": 1,
        "consumer_max_poll_records": 1,
        "offset_flush_interval_ms": 1,
        "offset_flush_timeout_ms": 1,
        "producer_batch_size": 1,
        "producer_buffer_memory": 1,
        "producer_compression_type": "foo",
        "producer_linger_ms": 1,
        "producer_max_request_size": 1,
        "scheduled_rebalance_max_delay_ms": 1,
        "session_timeout_ms": 1
    },
    "kafka_rest": true,
    "kafka_rest_authorization": true,
    "kafka_rest_config": {
        "consumer_enable_auto_commit": true,
        "consumer_request_max_bytes": 1,
        "consumer_request_timeout_ms": 1,
        "producer_acks": "foo",
        "producer_compression_type": "foo",
        "producer_linger_ms": 1,
        "producer_max_request_size": 1,
        "simpleconsumer_pool_size_max": 1
    },
    "kafka_version": "foo",
    "private_access": {
        "kafka": true,
        "kafka_connect": true,
        "kafka_rest": true,
        "prometheus": true,
        "schema_registry": true
    },
    "privatelink_access": {
        "jolokia": true,
        "kafka": true,
        "kafka_connect": true,
        "kafka_rest": true,
        "prometheus": true,
        "schema_registry": true
    },
    "public_access": {
        "kafka": true,
        "kafka_connect": true,
        "kafka_rest": true,
        "prometheus": true,
        "schema_registry": true
    },
    "schema_registry": true,
    "schema_registry_config": {
        "leader_eligibility": true,
        "topic_name": "foo"
    },
    "static_ips": true,
    "tiered_storage": {
        "enabled": true,
        "local_cache": {
            "size": 1
        }
    }
}`
const updateOnlyFields = `{
    "additional_backup_regions": [
        "foo"
    ],
    "custom_domain": "foo",
    "ip_filter": [
        {
            "description": "foo",
            "network": "foo"
        }
    ],
    "kafka": {
        "auto_create_topics_enable": true,
        "compression_type": "foo",
        "connections_max_idle_ms": 1,
        "default_replication_factor": 1,
        "group_initial_rebalance_delay_ms": 1,
        "group_max_session_timeout_ms": 1,
        "group_min_session_timeout_ms": 1,
        "log_cleaner_delete_retention_ms": 1,
        "log_cleaner_max_compaction_lag_ms": 1,
        "log_cleaner_min_cleanable_ratio": 1,
        "log_cleaner_min_compaction_lag_ms": 1,
        "log_cleanup_policy": "foo",
        "log_flush_interval_messages": 1,
        "log_flush_interval_ms": 1,
        "log_index_interval_bytes": 1,
        "log_index_size_max_bytes": 1,
        "log_local_retention_bytes": 1,
        "log_local_retention_ms": 1,
        "log_message_downconversion_enable": true,
        "log_message_timestamp_difference_max_ms": 1,
        "log_message_timestamp_type": "foo",
        "log_preallocate": true,
        "log_retention_bytes": 1,
        "log_retention_hours": 1,
        "log_retention_ms": 1,
        "log_roll_jitter_ms": 1,
        "log_roll_ms": 1,
        "log_segment_bytes": 1,
        "log_segment_delete_delay_ms": 1,
        "max_connections_per_ip": 1,
        "max_incremental_fetch_session_cache_slots": 1,
        "message_max_bytes": 1,
        "min_insync_replicas": 1,
        "num_partitions": 1,
        "offsets_retention_minutes": 1,
        "producer_purgatory_purge_interval_requests": 1,
        "replica_fetch_max_bytes": 1,
        "replica_fetch_response_max_bytes": 1,
        "sasl_oauthbearer_expected_audience": "foo",
        "sasl_oauthbearer_expected_issuer": "foo",
        "sasl_oauthbearer_jwks_endpoint_url": "foo",
        "sasl_oauthbearer_sub_claim_name": "foo",
        "socket_request_max_bytes": 1,
        "transaction_remove_expired_transaction_cleanup_interval_ms": 1,
        "transaction_state_log_segment_bytes": 1
    },
    "kafka_authentication_methods": {
        "certificate": true,
        "sasl": true
    },
    "kafka_connect": true,
    "kafka_connect_config": {
        "connector_client_config_override_policy": "foo",
        "consumer_auto_offset_reset": "foo",
        "consumer_fetch_max_bytes": 1,
        "consumer_isolation_level": "foo",
        "consumer_max_partition_fetch_bytes": 1,
        "consumer_max_poll_interval_ms": 1,
        "consumer_max_poll_records": 1,
        "offset_flush_interval_ms": 1,
        "offset_flush_timeout_ms": 1,
        "producer_batch_size": 1,
        "producer_buffer_memory": 1,
        "producer_compression_type": "foo",
        "producer_linger_ms": 1,
        "producer_max_request_size": 1,
        "scheduled_rebalance_max_delay_ms": 1,
        "session_timeout_ms": 1
    },
    "kafka_rest": true,
    "kafka_rest_authorization": true,
    "kafka_rest_config": {
        "consumer_enable_auto_commit": true,
        "consumer_request_max_bytes": 1,
        "consumer_request_timeout_ms": 1,
        "producer_acks": "foo",
        "producer_compression_type": "foo",
        "producer_linger_ms": 1,
        "producer_max_request_size": 1,
        "simpleconsumer_pool_size_max": 1
    },
    "kafka_version": "foo",
    "private_access": {
        "kafka": true,
        "kafka_connect": true,
        "kafka_rest": true,
        "prometheus": true,
        "schema_registry": true
    },
    "privatelink_access": {
        "jolokia": true,
        "kafka": true,
        "kafka_connect": true,
        "kafka_rest": true,
        "prometheus": true,
        "schema_registry": true
    },
    "public_access": {
        "kafka": true,
        "kafka_connect": true,
        "kafka_rest": true,
        "prometheus": true,
        "schema_registry": true
    },
    "schema_registry": true,
    "schema_registry_config": {
        "leader_eligibility": true,
        "topic_name": "foo"
    },
    "static_ips": true,
    "tiered_storage": {
        "enabled": true,
        "local_cache": {
            "size": 1
        }
    }
}`

func TestUserConfig(t *testing.T) {
	cases := []struct {
		name   string
		source string
		expect string
		create bool
	}{
		{
			name:   "fields to create resource",
			source: allFields,
			expect: allFields,
			create: true,
		},
		{
			name:   "only fields to update resource",
			source: allFields,
			expect: updateOnlyFields, // usually, fewer fields
			create: false,
		},
	}

	ctx := context.Background()
	diags := make(diag.Diagnostics, 0)
	for _, opt := range cases {
		t.Run(opt.name, func(t *testing.T) {
			dto := new(dtoUserConfig)
			err := json.Unmarshal([]byte(opt.source), dto)
			require.NoError(t, err)

			// From json to TF
			tfo := flattenUserConfig(ctx, diags, dto)
			require.Empty(t, diags)

			// From TF to json
			config := expandUserConfig(ctx, diags, tfo)
			require.Empty(t, diags)

			// Run specific marshal (create or update resource)
			dtoConfig, err := schemautil.MarshalUserConfig(config, opt.create)
			require.NoError(t, err)

			// Compares that output is strictly equal to the input
			// If so, the flow is valid
			b, err := json.MarshalIndent(dtoConfig, "", "    ")
			require.NoError(t, err)
			require.Empty(t, cmp.Diff(opt.expect, string(b)))
		})
	}
}
