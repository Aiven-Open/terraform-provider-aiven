// Code generated by user config generator. DO NOT EDIT.

package pg

import (
	"context"
	"encoding/json"
	"testing"

	"github.com/google/go-cmp/cmp"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/stretchr/testify/require"

	"github.com/aiven/terraform-provider-aiven/internal/schemautil"
)

const allFields = `{
    "additional_backup_regions": [
        "foo"
    ],
    "admin_password": "foo",
    "admin_username": "foo",
    "backup_hour": 1,
    "backup_minute": 1,
    "enable_ipv6": true,
    "ip_filter": [
        {
            "description": "foo",
            "network": "foo"
        }
    ],
    "migration": {
        "dbname": "foo",
        "host": "foo",
        "ignore_dbs": "foo",
        "method": "foo",
        "password": "foo",
        "port": 1,
        "ssl": true,
        "username": "foo"
    },
    "pg": {
        "autovacuum_analyze_scale_factor": 1,
        "autovacuum_analyze_threshold": 1,
        "autovacuum_freeze_max_age": 1,
        "autovacuum_max_workers": 1,
        "autovacuum_naptime": 1,
        "autovacuum_vacuum_cost_delay": 1,
        "autovacuum_vacuum_cost_limit": 1,
        "autovacuum_vacuum_scale_factor": 1,
        "autovacuum_vacuum_threshold": 1,
        "bgwriter_delay": 1,
        "bgwriter_flush_after": 1,
        "bgwriter_lru_maxpages": 1,
        "bgwriter_lru_multiplier": 1,
        "deadlock_timeout": 1,
        "default_toast_compression": "foo",
        "idle_in_transaction_session_timeout": 1,
        "jit": true,
        "log_autovacuum_min_duration": 1,
        "log_error_verbosity": "foo",
        "log_line_prefix": "foo",
        "log_min_duration_statement": 1,
        "log_temp_files": 1,
        "max_files_per_process": 1,
        "max_locks_per_transaction": 1,
        "max_logical_replication_workers": 1,
        "max_parallel_workers": 1,
        "max_parallel_workers_per_gather": 1,
        "max_pred_locks_per_transaction": 1,
        "max_prepared_transactions": 1,
        "max_replication_slots": 1,
        "max_slot_wal_keep_size": 1,
        "max_stack_depth": 1,
        "max_standby_archive_delay": 1,
        "max_standby_streaming_delay": 1,
        "max_wal_senders": 1,
        "max_worker_processes": 1,
        "pg_partman_bgw.interval": 1,
        "pg_partman_bgw.role": "foo",
        "pg_stat_monitor.pgsm_enable_query_plan": true,
        "pg_stat_monitor.pgsm_max_buckets": 1,
        "pg_stat_statements.track": "foo",
        "temp_file_limit": 1,
        "timezone": "foo",
        "track_activity_query_size": 1,
        "track_commit_timestamp": "foo",
        "track_functions": "foo",
        "track_io_timing": "foo",
        "wal_sender_timeout": 1,
        "wal_writer_delay": 1
    },
    "pg_read_replica": true,
    "pg_service_to_fork_from": "foo",
    "pg_stat_monitor_enable": true,
    "pg_version": "foo",
    "pgbouncer": {
        "autodb_idle_timeout": 1,
        "autodb_max_db_connections": 1,
        "autodb_pool_mode": "foo",
        "autodb_pool_size": 1,
        "ignore_startup_parameters": [
            "foo"
        ],
        "min_pool_size": 1,
        "server_idle_timeout": 1,
        "server_lifetime": 1,
        "server_reset_query_always": true
    },
    "pglookout": {
        "max_failover_replication_time_lag": 1
    },
    "private_access": {
        "pg": true,
        "pgbouncer": true,
        "prometheus": true
    },
    "privatelink_access": {
        "pg": true,
        "pgbouncer": true,
        "prometheus": true
    },
    "project_to_fork_from": "foo",
    "public_access": {
        "pg": true,
        "pgbouncer": true,
        "prometheus": true
    },
    "recovery_target_time": "foo",
    "service_to_fork_from": "foo",
    "shared_buffers_percentage": 1,
    "static_ips": true,
    "synchronous_replication": "foo",
    "timescaledb": {
        "max_background_workers": 1
    },
    "variant": "foo",
    "work_mem": 1
}`
const updateOnlyFields = `{
    "additional_backup_regions": [
        "foo"
    ],
    "backup_hour": 1,
    "backup_minute": 1,
    "enable_ipv6": true,
    "ip_filter": [
        {
            "description": "foo",
            "network": "foo"
        }
    ],
    "migration": {
        "dbname": "foo",
        "host": "foo",
        "ignore_dbs": "foo",
        "method": "foo",
        "password": "foo",
        "port": 1,
        "ssl": true,
        "username": "foo"
    },
    "pg": {
        "autovacuum_analyze_scale_factor": 1,
        "autovacuum_analyze_threshold": 1,
        "autovacuum_freeze_max_age": 1,
        "autovacuum_max_workers": 1,
        "autovacuum_naptime": 1,
        "autovacuum_vacuum_cost_delay": 1,
        "autovacuum_vacuum_cost_limit": 1,
        "autovacuum_vacuum_scale_factor": 1,
        "autovacuum_vacuum_threshold": 1,
        "bgwriter_delay": 1,
        "bgwriter_flush_after": 1,
        "bgwriter_lru_maxpages": 1,
        "bgwriter_lru_multiplier": 1,
        "deadlock_timeout": 1,
        "default_toast_compression": "foo",
        "idle_in_transaction_session_timeout": 1,
        "jit": true,
        "log_autovacuum_min_duration": 1,
        "log_error_verbosity": "foo",
        "log_line_prefix": "foo",
        "log_min_duration_statement": 1,
        "log_temp_files": 1,
        "max_files_per_process": 1,
        "max_locks_per_transaction": 1,
        "max_logical_replication_workers": 1,
        "max_parallel_workers": 1,
        "max_parallel_workers_per_gather": 1,
        "max_pred_locks_per_transaction": 1,
        "max_prepared_transactions": 1,
        "max_replication_slots": 1,
        "max_slot_wal_keep_size": 1,
        "max_stack_depth": 1,
        "max_standby_archive_delay": 1,
        "max_standby_streaming_delay": 1,
        "max_wal_senders": 1,
        "max_worker_processes": 1,
        "pg_partman_bgw.interval": 1,
        "pg_partman_bgw.role": "foo",
        "pg_stat_monitor.pgsm_enable_query_plan": true,
        "pg_stat_monitor.pgsm_max_buckets": 1,
        "pg_stat_statements.track": "foo",
        "temp_file_limit": 1,
        "timezone": "foo",
        "track_activity_query_size": 1,
        "track_commit_timestamp": "foo",
        "track_functions": "foo",
        "track_io_timing": "foo",
        "wal_sender_timeout": 1,
        "wal_writer_delay": 1
    },
    "pg_read_replica": true,
    "pg_stat_monitor_enable": true,
    "pg_version": "foo",
    "pgbouncer": {
        "autodb_idle_timeout": 1,
        "autodb_max_db_connections": 1,
        "autodb_pool_mode": "foo",
        "autodb_pool_size": 1,
        "ignore_startup_parameters": [
            "foo"
        ],
        "min_pool_size": 1,
        "server_idle_timeout": 1,
        "server_lifetime": 1,
        "server_reset_query_always": true
    },
    "pglookout": {
        "max_failover_replication_time_lag": 1
    },
    "private_access": {
        "pg": true,
        "pgbouncer": true,
        "prometheus": true
    },
    "privatelink_access": {
        "pg": true,
        "pgbouncer": true,
        "prometheus": true
    },
    "public_access": {
        "pg": true,
        "pgbouncer": true,
        "prometheus": true
    },
    "shared_buffers_percentage": 1,
    "static_ips": true,
    "synchronous_replication": "foo",
    "timescaledb": {
        "max_background_workers": 1
    },
    "variant": "foo",
    "work_mem": 1
}`

func TestUserConfig(t *testing.T) {
	cases := []struct {
		name   string
		source string
		expect string
		create bool
	}{
		{
			name:   "fields to create resource",
			source: allFields,
			expect: allFields,
			create: true,
		},
		{
			name:   "only fields to update resource",
			source: allFields,
			expect: updateOnlyFields, // usually, fewer fields
			create: false,
		},
	}

	ctx := context.Background()
	diags := make(diag.Diagnostics, 0)
	for _, opt := range cases {
		t.Run(opt.name, func(t *testing.T) {
			dto := new(dtoUserConfig)
			err := json.Unmarshal([]byte(opt.source), dto)
			require.NoError(t, err)

			// From json to TF
			tfo := flattenUserConfig(ctx, diags, dto)
			require.Empty(t, diags)

			// From TF to json
			config := expandUserConfig(ctx, diags, tfo)
			require.Empty(t, diags)

			// Run specific marshal (create or update resource)
			dtoConfig, err := schemautil.MarshalUserConfig(config, opt.create)
			require.NoError(t, err)

			// Compares that output is strictly equal to the input
			// If so, the flow is valid
			b, err := json.MarshalIndent(dtoConfig, "", "    ")
			require.NoError(t, err)
			require.Empty(t, cmp.Diff(opt.expect, string(b)))
		})
	}
}
