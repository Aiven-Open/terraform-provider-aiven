// Code generated by user config generator. DO NOT EDIT.

package m3db

import (
	"context"
	"encoding/json"

	setvalidator "github.com/hashicorp/terraform-plugin-framework-validators/setvalidator"
	attr "github.com/hashicorp/terraform-plugin-framework/attr"
	datasource "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	diag "github.com/hashicorp/terraform-plugin-framework/diag"
	resource "github.com/hashicorp/terraform-plugin-framework/resource/schema"
	validator "github.com/hashicorp/terraform-plugin-framework/schema/validator"
	types "github.com/hashicorp/terraform-plugin-framework/types"

	schemautil "github.com/aiven/terraform-provider-aiven/internal/schemautil"
)

// NewResourceSchema returns resource schema
func NewResourceSchema() resource.SetNestedBlock {
	return resource.SetNestedBlock{
		Description: "M3db user configurable settings",
		NestedObject: resource.NestedBlockObject{
			Attributes: map[string]resource.Attribute{
				"additional_backup_regions": resource.SetAttribute{
					Computed:    true,
					Description: "Additional Cloud Regions for Backup Replication.",
					ElementType: types.StringType,
					Optional:    true,
					Validators:  []validator.Set{setvalidator.SizeAtMost(1)},
				},
				"custom_domain": resource.StringAttribute{
					Computed:    true,
					Description: "Serve the web frontend using a custom CNAME pointing to the Aiven DNS name.",
					Optional:    true,
				},
				"m3_version": resource.StringAttribute{
					Computed:    true,
					Description: "M3 major version (deprecated, use m3db_version).",
					Optional:    true,
				},
				"m3coordinator_enable_graphite_carbon_ingest": resource.BoolAttribute{
					Computed:    true,
					Description: "Enables access to Graphite Carbon plaintext metrics ingestion. It can be enabled only for services inside VPCs. The metrics are written to aggregated namespaces only.",
					Optional:    true,
				},
				"m3db_version": resource.StringAttribute{
					Computed:    true,
					Description: "M3 major version (the minimum compatible version).",
					Optional:    true,
				},
				"project_to_fork_from": resource.StringAttribute{
					Computed:    true,
					Description: "Name of another project to fork a service from. This has effect only when a new service is being created.",
					Optional:    true,
				},
				"service_to_fork_from": resource.StringAttribute{
					Computed:    true,
					Description: "Name of another service to fork from. This has effect only when a new service is being created.",
					Optional:    true,
				},
				"static_ips": resource.BoolAttribute{
					Computed:    true,
					Description: "Use static public IP addresses.",
					Optional:    true,
				},
			},
			Blocks: map[string]resource.Block{
				"ip_filter": resource.SetNestedBlock{
					Description: "Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'",
					NestedObject: resource.NestedBlockObject{Attributes: map[string]resource.Attribute{
						"description": resource.StringAttribute{
							Computed:    true,
							Description: "Description for IP filter list entry.",
							Optional:    true,
						},
						"network": resource.StringAttribute{
							Description: "CIDR address block.",
							Required:    true,
						},
					}},
					Validators: []validator.Set{setvalidator.SizeAtMost(1024)},
				},
				"limits": resource.SetNestedBlock{
					Description: "M3 limits",
					NestedObject: resource.NestedBlockObject{Attributes: map[string]resource.Attribute{
						"max_recently_queried_series_blocks": resource.Int64Attribute{
							Computed:    true,
							Description: "The maximum number of blocks that can be read in a given lookback period.",
							Optional:    true,
						},
						"max_recently_queried_series_disk_bytes_read": resource.Int64Attribute{
							Computed:    true,
							Description: "The maximum number of disk bytes that can be read in a given lookback period.",
							Optional:    true,
						},
						"max_recently_queried_series_lookback": resource.StringAttribute{
							Computed:    true,
							Description: "The lookback period for 'max_recently_queried_series_blocks' and 'max_recently_queried_series_disk_bytes_read'.",
							Optional:    true,
						},
						"query_docs": resource.Int64Attribute{
							Computed:    true,
							Description: "The maximum number of docs fetched in single query.",
							Optional:    true,
						},
						"query_require_exhaustive": resource.BoolAttribute{
							Computed:    true,
							Description: "When query limits are exceeded, whether to return error or return partial results.",
							Optional:    true,
						},
						"query_series": resource.Int64Attribute{
							Computed:    true,
							Description: "The maximum number of series fetched in single query.",
							Optional:    true,
						},
					}},
				},
				"m3": resource.SetNestedBlock{
					Description: "M3 specific configuration options",
					NestedObject: resource.NestedBlockObject{Blocks: map[string]resource.Block{"tag_options": resource.SetNestedBlock{
						Description: "M3 Tag Options",
						NestedObject: resource.NestedBlockObject{Attributes: map[string]resource.Attribute{
							"allow_tag_name_duplicates": resource.BoolAttribute{
								Computed:    true,
								Description: "Allows for duplicate tags to appear on series (not allowed by default).",
								Optional:    true,
							},
							"allow_tag_value_empty": resource.BoolAttribute{
								Computed:    true,
								Description: "Allows for empty tags to appear on series (not allowed by default).",
								Optional:    true,
							},
						}},
					}}},
				},
				"namespaces": resource.SetNestedBlock{
					Description: "List of M3 namespaces",
					NestedObject: resource.NestedBlockObject{
						Attributes: map[string]resource.Attribute{
							"name": resource.StringAttribute{
								Description: "The name of the namespace.",
								Required:    true,
							},
							"resolution": resource.StringAttribute{
								Computed:    true,
								Description: "The resolution for an aggregated namespace.",
								Optional:    true,
							},
							"type": resource.StringAttribute{
								Description: "The type of aggregation (aggregated/unaggregated).",
								Required:    true,
							},
						},
						Blocks: map[string]resource.Block{"options": resource.SetNestedBlock{
							Description: "Namespace options",
							NestedObject: resource.NestedBlockObject{
								Attributes: map[string]resource.Attribute{
									"snapshot_enabled": resource.BoolAttribute{
										Computed:    true,
										Description: "Controls whether M3DB will create snapshot files for this namespace.",
										Optional:    true,
									},
									"writes_to_commitlog": resource.BoolAttribute{
										Computed:    true,
										Description: "Controls whether M3DB will include writes to this namespace in the commitlog.",
										Optional:    true,
									},
								},
								Blocks: map[string]resource.Block{"retention_options": resource.SetNestedBlock{
									Description: "Retention options",
									NestedObject: resource.NestedBlockObject{Attributes: map[string]resource.Attribute{
										"block_data_expiry_duration": resource.StringAttribute{
											Computed:    true,
											Description: "Controls how long we wait before expiring stale data.",
											Optional:    true,
										},
										"blocksize_duration": resource.StringAttribute{
											Computed:    true,
											Description: "Controls how long to keep a block in memory before flushing to a fileset on disk.",
											Optional:    true,
										},
										"buffer_future_duration": resource.StringAttribute{
											Computed:    true,
											Description: "Controls how far into the future writes to the namespace will be accepted.",
											Optional:    true,
										},
										"buffer_past_duration": resource.StringAttribute{
											Computed:    true,
											Description: "Controls how far into the past writes to the namespace will be accepted.",
											Optional:    true,
										},
										"retention_period_duration": resource.StringAttribute{
											Computed:    true,
											Description: "Controls the duration of time that M3DB will retain data for the namespace.",
											Optional:    true,
										},
									}},
								}},
							},
						}},
					},
					Validators: []validator.Set{setvalidator.SizeAtMost(2147483647)},
				},
				"private_access": resource.SetNestedBlock{
					Description: "Allow access to selected service ports from private networks",
					NestedObject: resource.NestedBlockObject{Attributes: map[string]resource.Attribute{"m3coordinator": resource.BoolAttribute{
						Computed:    true,
						Description: "Allow clients to connect to m3coordinator with a DNS name that always resolves to the service's private IP addresses. Only available in certain network locations.",
						Optional:    true,
					}}},
				},
				"public_access": resource.SetNestedBlock{
					Description: "Allow access to selected service ports from the public Internet",
					NestedObject: resource.NestedBlockObject{Attributes: map[string]resource.Attribute{"m3coordinator": resource.BoolAttribute{
						Computed:    true,
						Description: "Allow clients to connect to m3coordinator from the public internet for service nodes that are in a project VPC or another type of private network.",
						Optional:    true,
					}}},
				},
				"rules": resource.SetNestedBlock{
					Description: "M3 rules",
					NestedObject: resource.NestedBlockObject{Blocks: map[string]resource.Block{"mapping": resource.SetNestedBlock{
						Description: "List of M3 mapping rules",
						NestedObject: resource.NestedBlockObject{
							Attributes: map[string]resource.Attribute{
								"aggregations": resource.SetAttribute{
									Computed:    true,
									Description: "List of aggregations to be applied.",
									ElementType: types.StringType,
									Optional:    true,
									Validators:  []validator.Set{setvalidator.SizeAtMost(10)},
								},
								"drop": resource.BoolAttribute{
									Computed:    true,
									Description: "Only store the derived metric (as specified in the roll-up rules), if any.",
									Optional:    true,
								},
								"filter": resource.StringAttribute{
									Description: "Matching metric names with wildcards (using __name__:wildcard) or matching tags and their (optionally wildcarded) values. For value, ! can be used at start of value for negation, and multiple filters can be supplied using space as separator.",
									Required:    true,
								},
								"name": resource.StringAttribute{
									Computed:    true,
									Description: "The (optional) name of the rule.",
									Optional:    true,
								},
							},
							Blocks: map[string]resource.Block{
								"namespaces": resource.SetNestedBlock{
									Description: "This rule will be used to store the metrics in the given namespace(s). If a namespace is target of rules, the global default aggregation will be automatically disabled. Note that specifying filters that match no namespaces whatsoever will be returned as an error",
									NestedObject: resource.NestedBlockObject{Attributes: map[string]resource.Attribute{
										"resolution": resource.StringAttribute{
											Description: "The resolution for the matching namespace.",
											Required:    true,
										},
										"retention": resource.StringAttribute{
											Computed:    true,
											Description: "The retention period of the matching namespace.",
											Optional:    true,
										},
									}},
									Validators: []validator.Set{setvalidator.SizeAtMost(10)},
								},
								"tags": resource.SetNestedBlock{
									Description: "List of tags to be appended to matching metrics",
									NestedObject: resource.NestedBlockObject{Attributes: map[string]resource.Attribute{
										"name": resource.StringAttribute{
											Description: "Name of the tag.",
											Required:    true,
										},
										"value": resource.StringAttribute{
											Description: "Value of the tag.",
											Required:    true,
										},
									}},
									Validators: []validator.Set{setvalidator.SizeAtMost(10)},
								},
							},
						},
						Validators: []validator.Set{setvalidator.SizeAtMost(10)},
					}}},
				},
			},
		},
		Validators: []validator.Set{setvalidator.SizeAtMost(1)},
	}
}

// NewDataSourceSchema returns datasource schema
func NewDataSourceSchema() datasource.SetNestedBlock {
	return datasource.SetNestedBlock{
		Description: "M3db user configurable settings",
		NestedObject: datasource.NestedBlockObject{
			Attributes: map[string]datasource.Attribute{
				"additional_backup_regions": datasource.SetAttribute{
					Computed:    true,
					Description: "Additional Cloud Regions for Backup Replication.",
					ElementType: types.StringType,
					Validators:  []validator.Set{setvalidator.SizeAtMost(1)},
				},
				"custom_domain": datasource.StringAttribute{
					Computed:    true,
					Description: "Serve the web frontend using a custom CNAME pointing to the Aiven DNS name.",
				},
				"m3_version": datasource.StringAttribute{
					Computed:    true,
					Description: "M3 major version (deprecated, use m3db_version).",
				},
				"m3coordinator_enable_graphite_carbon_ingest": datasource.BoolAttribute{
					Computed:    true,
					Description: "Enables access to Graphite Carbon plaintext metrics ingestion. It can be enabled only for services inside VPCs. The metrics are written to aggregated namespaces only.",
				},
				"m3db_version": datasource.StringAttribute{
					Computed:    true,
					Description: "M3 major version (the minimum compatible version).",
				},
				"project_to_fork_from": datasource.StringAttribute{
					Computed:    true,
					Description: "Name of another project to fork a service from. This has effect only when a new service is being created.",
				},
				"service_to_fork_from": datasource.StringAttribute{
					Computed:    true,
					Description: "Name of another service to fork from. This has effect only when a new service is being created.",
				},
				"static_ips": datasource.BoolAttribute{
					Computed:    true,
					Description: "Use static public IP addresses.",
				},
			},
			Blocks: map[string]datasource.Block{
				"ip_filter": datasource.SetNestedBlock{
					Description: "Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'",
					NestedObject: datasource.NestedBlockObject{Attributes: map[string]datasource.Attribute{
						"description": datasource.StringAttribute{
							Computed:    true,
							Description: "Description for IP filter list entry.",
						},
						"network": datasource.StringAttribute{
							Computed:    true,
							Description: "CIDR address block.",
						},
					}},
					Validators: []validator.Set{setvalidator.SizeAtMost(1024)},
				},
				"limits": datasource.SetNestedBlock{
					Description: "M3 limits",
					NestedObject: datasource.NestedBlockObject{Attributes: map[string]datasource.Attribute{
						"max_recently_queried_series_blocks": datasource.Int64Attribute{
							Computed:    true,
							Description: "The maximum number of blocks that can be read in a given lookback period.",
						},
						"max_recently_queried_series_disk_bytes_read": datasource.Int64Attribute{
							Computed:    true,
							Description: "The maximum number of disk bytes that can be read in a given lookback period.",
						},
						"max_recently_queried_series_lookback": datasource.StringAttribute{
							Computed:    true,
							Description: "The lookback period for 'max_recently_queried_series_blocks' and 'max_recently_queried_series_disk_bytes_read'.",
						},
						"query_docs": datasource.Int64Attribute{
							Computed:    true,
							Description: "The maximum number of docs fetched in single query.",
						},
						"query_require_exhaustive": datasource.BoolAttribute{
							Computed:    true,
							Description: "When query limits are exceeded, whether to return error or return partial results.",
						},
						"query_series": datasource.Int64Attribute{
							Computed:    true,
							Description: "The maximum number of series fetched in single query.",
						},
					}},
				},
				"m3": datasource.SetNestedBlock{
					Description: "M3 specific configuration options",
					NestedObject: datasource.NestedBlockObject{Blocks: map[string]datasource.Block{"tag_options": datasource.SetNestedBlock{
						Description: "M3 Tag Options",
						NestedObject: datasource.NestedBlockObject{Attributes: map[string]datasource.Attribute{
							"allow_tag_name_duplicates": datasource.BoolAttribute{
								Computed:    true,
								Description: "Allows for duplicate tags to appear on series (not allowed by default).",
							},
							"allow_tag_value_empty": datasource.BoolAttribute{
								Computed:    true,
								Description: "Allows for empty tags to appear on series (not allowed by default).",
							},
						}},
					}}},
				},
				"namespaces": datasource.SetNestedBlock{
					Description: "List of M3 namespaces",
					NestedObject: datasource.NestedBlockObject{
						Attributes: map[string]datasource.Attribute{
							"name": datasource.StringAttribute{
								Computed:    true,
								Description: "The name of the namespace.",
							},
							"resolution": datasource.StringAttribute{
								Computed:    true,
								Description: "The resolution for an aggregated namespace.",
							},
							"type": datasource.StringAttribute{
								Computed:    true,
								Description: "The type of aggregation (aggregated/unaggregated).",
							},
						},
						Blocks: map[string]datasource.Block{"options": datasource.SetNestedBlock{
							Description: "Namespace options",
							NestedObject: datasource.NestedBlockObject{
								Attributes: map[string]datasource.Attribute{
									"snapshot_enabled": datasource.BoolAttribute{
										Computed:    true,
										Description: "Controls whether M3DB will create snapshot files for this namespace.",
									},
									"writes_to_commitlog": datasource.BoolAttribute{
										Computed:    true,
										Description: "Controls whether M3DB will include writes to this namespace in the commitlog.",
									},
								},
								Blocks: map[string]datasource.Block{"retention_options": datasource.SetNestedBlock{
									Description: "Retention options",
									NestedObject: datasource.NestedBlockObject{Attributes: map[string]datasource.Attribute{
										"block_data_expiry_duration": datasource.StringAttribute{
											Computed:    true,
											Description: "Controls how long we wait before expiring stale data.",
										},
										"blocksize_duration": datasource.StringAttribute{
											Computed:    true,
											Description: "Controls how long to keep a block in memory before flushing to a fileset on disk.",
										},
										"buffer_future_duration": datasource.StringAttribute{
											Computed:    true,
											Description: "Controls how far into the future writes to the namespace will be accepted.",
										},
										"buffer_past_duration": datasource.StringAttribute{
											Computed:    true,
											Description: "Controls how far into the past writes to the namespace will be accepted.",
										},
										"retention_period_duration": datasource.StringAttribute{
											Computed:    true,
											Description: "Controls the duration of time that M3DB will retain data for the namespace.",
										},
									}},
								}},
							},
						}},
					},
					Validators: []validator.Set{setvalidator.SizeAtMost(2147483647)},
				},
				"private_access": datasource.SetNestedBlock{
					Description: "Allow access to selected service ports from private networks",
					NestedObject: datasource.NestedBlockObject{Attributes: map[string]datasource.Attribute{"m3coordinator": datasource.BoolAttribute{
						Computed:    true,
						Description: "Allow clients to connect to m3coordinator with a DNS name that always resolves to the service's private IP addresses. Only available in certain network locations.",
					}}},
				},
				"public_access": datasource.SetNestedBlock{
					Description: "Allow access to selected service ports from the public Internet",
					NestedObject: datasource.NestedBlockObject{Attributes: map[string]datasource.Attribute{"m3coordinator": datasource.BoolAttribute{
						Computed:    true,
						Description: "Allow clients to connect to m3coordinator from the public internet for service nodes that are in a project VPC or another type of private network.",
					}}},
				},
				"rules": datasource.SetNestedBlock{
					Description: "M3 rules",
					NestedObject: datasource.NestedBlockObject{Blocks: map[string]datasource.Block{"mapping": datasource.SetNestedBlock{
						Description: "List of M3 mapping rules",
						NestedObject: datasource.NestedBlockObject{
							Attributes: map[string]datasource.Attribute{
								"aggregations": datasource.SetAttribute{
									Computed:    true,
									Description: "List of aggregations to be applied.",
									ElementType: types.StringType,
									Validators:  []validator.Set{setvalidator.SizeAtMost(10)},
								},
								"drop": datasource.BoolAttribute{
									Computed:    true,
									Description: "Only store the derived metric (as specified in the roll-up rules), if any.",
								},
								"filter": datasource.StringAttribute{
									Computed:    true,
									Description: "Matching metric names with wildcards (using __name__:wildcard) or matching tags and their (optionally wildcarded) values. For value, ! can be used at start of value for negation, and multiple filters can be supplied using space as separator.",
								},
								"name": datasource.StringAttribute{
									Computed:    true,
									Description: "The (optional) name of the rule.",
								},
							},
							Blocks: map[string]datasource.Block{
								"namespaces": datasource.SetNestedBlock{
									Description: "This rule will be used to store the metrics in the given namespace(s). If a namespace is target of rules, the global default aggregation will be automatically disabled. Note that specifying filters that match no namespaces whatsoever will be returned as an error",
									NestedObject: datasource.NestedBlockObject{Attributes: map[string]datasource.Attribute{
										"resolution": datasource.StringAttribute{
											Computed:    true,
											Description: "The resolution for the matching namespace.",
										},
										"retention": datasource.StringAttribute{
											Computed:    true,
											Description: "The retention period of the matching namespace.",
										},
									}},
									Validators: []validator.Set{setvalidator.SizeAtMost(10)},
								},
								"tags": datasource.SetNestedBlock{
									Description: "List of tags to be appended to matching metrics",
									NestedObject: datasource.NestedBlockObject{Attributes: map[string]datasource.Attribute{
										"name": datasource.StringAttribute{
											Computed:    true,
											Description: "Name of the tag.",
										},
										"value": datasource.StringAttribute{
											Computed:    true,
											Description: "Value of the tag.",
										},
									}},
									Validators: []validator.Set{setvalidator.SizeAtMost(10)},
								},
							},
						},
						Validators: []validator.Set{setvalidator.SizeAtMost(10)},
					}}},
				},
			},
		},
		Validators: []validator.Set{setvalidator.SizeAtMost(1)},
	}
}

// tfoUserConfig M3db user configurable settings
type tfoUserConfig struct {
	AdditionalBackupRegions                 types.Set    `tfsdk:"additional_backup_regions"`
	CustomDomain                            types.String `tfsdk:"custom_domain"`
	IpFilter                                types.Set    `tfsdk:"ip_filter"`
	Limits                                  types.Set    `tfsdk:"limits"`
	M3                                      types.Set    `tfsdk:"m3"`
	M3Version                               types.String `tfsdk:"m3_version"`
	M3coordinatorEnableGraphiteCarbonIngest types.Bool   `tfsdk:"m3coordinator_enable_graphite_carbon_ingest"`
	M3dbVersion                             types.String `tfsdk:"m3db_version"`
	Namespaces                              types.Set    `tfsdk:"namespaces"`
	PrivateAccess                           types.Set    `tfsdk:"private_access"`
	ProjectToForkFrom                       types.String `tfsdk:"project_to_fork_from"`
	PublicAccess                            types.Set    `tfsdk:"public_access"`
	Rules                                   types.Set    `tfsdk:"rules"`
	ServiceToForkFrom                       types.String `tfsdk:"service_to_fork_from"`
	StaticIps                               types.Bool   `tfsdk:"static_ips"`
}

// dtoUserConfig request/response object
type dtoUserConfig struct {
	AdditionalBackupRegions                 []string          `groups:"create,update" json:"additional_backup_regions,omitempty"`
	CustomDomain                            *string           `groups:"create,update" json:"custom_domain,omitempty"`
	IpFilter                                []*dtoIpFilter    `groups:"create,update" json:"ip_filter,omitempty"`
	Limits                                  *dtoLimits        `groups:"create,update" json:"limits,omitempty"`
	M3                                      *dtoM3            `groups:"create,update" json:"m3,omitempty"`
	M3Version                               *string           `groups:"create,update" json:"m3_version,omitempty"`
	M3coordinatorEnableGraphiteCarbonIngest *bool             `groups:"create,update" json:"m3coordinator_enable_graphite_carbon_ingest,omitempty"`
	M3dbVersion                             *string           `groups:"create,update" json:"m3db_version,omitempty"`
	Namespaces                              []*dtoNamespaces  `groups:"create,update" json:"namespaces,omitempty"`
	PrivateAccess                           *dtoPrivateAccess `groups:"create,update" json:"private_access,omitempty"`
	ProjectToForkFrom                       *string           `groups:"create" json:"project_to_fork_from,omitempty"`
	PublicAccess                            *dtoPublicAccess  `groups:"create,update" json:"public_access,omitempty"`
	Rules                                   *dtoRules         `groups:"create,update" json:"rules,omitempty"`
	ServiceToForkFrom                       *string           `groups:"create" json:"service_to_fork_from,omitempty"`
	StaticIps                               *bool             `groups:"create,update" json:"static_ips,omitempty"`
}

// expandUserConfig expands tf object into dto object
func expandUserConfig(ctx context.Context, diags diag.Diagnostics, o *tfoUserConfig) *dtoUserConfig {
	additionalBackupRegionsVar := schemautil.ExpandSet[string](ctx, diags, o.AdditionalBackupRegions)
	if diags.HasError() {
		return nil
	}
	ipFilterVar := schemautil.ExpandSetNested(ctx, diags, expandIpFilter, o.IpFilter)
	if diags.HasError() {
		return nil
	}
	limitsVar := schemautil.ExpandSetBlockNested(ctx, diags, expandLimits, o.Limits)
	if diags.HasError() {
		return nil
	}
	m3Var := schemautil.ExpandSetBlockNested(ctx, diags, expandM3, o.M3)
	if diags.HasError() {
		return nil
	}
	namespacesVar := schemautil.ExpandSetNested(ctx, diags, expandNamespaces, o.Namespaces)
	if diags.HasError() {
		return nil
	}
	privateAccessVar := schemautil.ExpandSetBlockNested(ctx, diags, expandPrivateAccess, o.PrivateAccess)
	if diags.HasError() {
		return nil
	}
	publicAccessVar := schemautil.ExpandSetBlockNested(ctx, diags, expandPublicAccess, o.PublicAccess)
	if diags.HasError() {
		return nil
	}
	rulesVar := schemautil.ExpandSetBlockNested(ctx, diags, expandRules, o.Rules)
	if diags.HasError() {
		return nil
	}
	return &dtoUserConfig{
		AdditionalBackupRegions:                 additionalBackupRegionsVar,
		CustomDomain:                            schemautil.ValueStringPointer(o.CustomDomain),
		IpFilter:                                ipFilterVar,
		Limits:                                  limitsVar,
		M3:                                      m3Var,
		M3Version:                               schemautil.ValueStringPointer(o.M3Version),
		M3coordinatorEnableGraphiteCarbonIngest: schemautil.ValueBoolPointer(o.M3coordinatorEnableGraphiteCarbonIngest),
		M3dbVersion:                             schemautil.ValueStringPointer(o.M3dbVersion),
		Namespaces:                              namespacesVar,
		PrivateAccess:                           privateAccessVar,
		ProjectToForkFrom:                       schemautil.ValueStringPointer(o.ProjectToForkFrom),
		PublicAccess:                            publicAccessVar,
		Rules:                                   rulesVar,
		ServiceToForkFrom:                       schemautil.ValueStringPointer(o.ServiceToForkFrom),
		StaticIps:                               schemautil.ValueBoolPointer(o.StaticIps),
	}
}

// flattenUserConfig flattens dto object into tf object
func flattenUserConfig(ctx context.Context, diags diag.Diagnostics, o *dtoUserConfig) *tfoUserConfig {
	additionalBackupRegionsVar, d := types.SetValueFrom(ctx, types.StringType, o.AdditionalBackupRegions)
	diags.Append(d...)
	if diags.HasError() {
		return nil
	}
	ipFilterVar := schemautil.FlattenSetNested(ctx, diags, flattenIpFilter, o.IpFilter, ipFilterAttrs)
	if diags.HasError() {
		return nil
	}
	limitsVar := schemautil.FlattenSetBlockNested(ctx, diags, flattenLimits, o.Limits, limitsAttrs)
	if diags.HasError() {
		return nil
	}
	m3Var := schemautil.FlattenSetBlockNested(ctx, diags, flattenM3, o.M3, m3Attrs)
	if diags.HasError() {
		return nil
	}
	namespacesVar := schemautil.FlattenSetNested(ctx, diags, flattenNamespaces, o.Namespaces, namespacesAttrs)
	if diags.HasError() {
		return nil
	}
	privateAccessVar := schemautil.FlattenSetBlockNested(ctx, diags, flattenPrivateAccess, o.PrivateAccess, privateAccessAttrs)
	if diags.HasError() {
		return nil
	}
	publicAccessVar := schemautil.FlattenSetBlockNested(ctx, diags, flattenPublicAccess, o.PublicAccess, publicAccessAttrs)
	if diags.HasError() {
		return nil
	}
	rulesVar := schemautil.FlattenSetBlockNested(ctx, diags, flattenRules, o.Rules, rulesAttrs)
	if diags.HasError() {
		return nil
	}
	return &tfoUserConfig{
		AdditionalBackupRegions:                 additionalBackupRegionsVar,
		CustomDomain:                            types.StringPointerValue(o.CustomDomain),
		IpFilter:                                ipFilterVar,
		Limits:                                  limitsVar,
		M3:                                      m3Var,
		M3Version:                               types.StringPointerValue(o.M3Version),
		M3coordinatorEnableGraphiteCarbonIngest: types.BoolPointerValue(o.M3coordinatorEnableGraphiteCarbonIngest),
		M3dbVersion:                             types.StringPointerValue(o.M3dbVersion),
		Namespaces:                              namespacesVar,
		PrivateAccess:                           privateAccessVar,
		ProjectToForkFrom:                       types.StringPointerValue(o.ProjectToForkFrom),
		PublicAccess:                            publicAccessVar,
		Rules:                                   rulesVar,
		ServiceToForkFrom:                       types.StringPointerValue(o.ServiceToForkFrom),
		StaticIps:                               types.BoolPointerValue(o.StaticIps),
	}
}

var userConfigAttrs = map[string]attr.Type{
	"additional_backup_regions": types.SetType{ElemType: types.StringType},
	"custom_domain":             types.StringType,
	"ip_filter":                 types.SetType{ElemType: types.ObjectType{AttrTypes: ipFilterAttrs}},
	"limits":                    types.SetType{ElemType: types.ObjectType{AttrTypes: limitsAttrs}},
	"m3":                        types.SetType{ElemType: types.ObjectType{AttrTypes: m3Attrs}},
	"m3_version":                types.StringType,
	"m3coordinator_enable_graphite_carbon_ingest": types.BoolType,
	"m3db_version":         types.StringType,
	"namespaces":           types.SetType{ElemType: types.ObjectType{AttrTypes: namespacesAttrs}},
	"private_access":       types.SetType{ElemType: types.ObjectType{AttrTypes: privateAccessAttrs}},
	"project_to_fork_from": types.StringType,
	"public_access":        types.SetType{ElemType: types.ObjectType{AttrTypes: publicAccessAttrs}},
	"rules":                types.SetType{ElemType: types.ObjectType{AttrTypes: rulesAttrs}},
	"service_to_fork_from": types.StringType,
	"static_ips":           types.BoolType,
}

// tfoIpFilter CIDR address block, either as a string, or in a dict with an optional description field
type tfoIpFilter struct {
	Description types.String `tfsdk:"description"`
	Network     types.String `tfsdk:"network"`
}

// dtoIpFilter request/response object
type dtoIpFilter struct {
	Description *string `groups:"create,update" json:"description,omitempty"`
	Network     string  `groups:"create,update" json:"network"`
}

func (d *dtoIpFilter) UnmarshalJSON(data []byte) error {
	var s string
	err := json.Unmarshal(data, &s)
	if err == nil {
		d.Network = s
		return nil
	}

	type obj dtoIpFilter
	o := &struct {
		Description *string `groups:"create,update" json:"description,omitempty"`
		Network     string  `groups:"create,update" json:"network"`
	}{}
	err = json.Unmarshal(data, o)
	if err != nil {
		return err
	}

	d.Description = o.Description
	d.Network = o.Network
	return nil
}

// expandIpFilter expands tf object into dto object
func expandIpFilter(ctx context.Context, diags diag.Diagnostics, o *tfoIpFilter) *dtoIpFilter {
	return &dtoIpFilter{
		Description: schemautil.ValueStringPointer(o.Description),
		Network:     o.Network.ValueString(),
	}
}

// flattenIpFilter flattens dto object into tf object
func flattenIpFilter(ctx context.Context, diags diag.Diagnostics, o *dtoIpFilter) *tfoIpFilter {
	return &tfoIpFilter{
		Description: types.StringPointerValue(o.Description),
		Network:     types.StringValue(o.Network),
	}
}

var ipFilterAttrs = map[string]attr.Type{
	"description": types.StringType,
	"network":     types.StringType,
}

// tfoLimits M3 limits
type tfoLimits struct {
	MaxRecentlyQueriedSeriesBlocks        types.Int64  `tfsdk:"max_recently_queried_series_blocks"`
	MaxRecentlyQueriedSeriesDiskBytesRead types.Int64  `tfsdk:"max_recently_queried_series_disk_bytes_read"`
	MaxRecentlyQueriedSeriesLookback      types.String `tfsdk:"max_recently_queried_series_lookback"`
	QueryDocs                             types.Int64  `tfsdk:"query_docs"`
	QueryRequireExhaustive                types.Bool   `tfsdk:"query_require_exhaustive"`
	QuerySeries                           types.Int64  `tfsdk:"query_series"`
}

// dtoLimits request/response object
type dtoLimits struct {
	MaxRecentlyQueriedSeriesBlocks        *int64  `groups:"create,update" json:"max_recently_queried_series_blocks,omitempty"`
	MaxRecentlyQueriedSeriesDiskBytesRead *int64  `groups:"create,update" json:"max_recently_queried_series_disk_bytes_read,omitempty"`
	MaxRecentlyQueriedSeriesLookback      *string `groups:"create,update" json:"max_recently_queried_series_lookback,omitempty"`
	QueryDocs                             *int64  `groups:"create,update" json:"query_docs,omitempty"`
	QueryRequireExhaustive                *bool   `groups:"create,update" json:"query_require_exhaustive,omitempty"`
	QuerySeries                           *int64  `groups:"create,update" json:"query_series,omitempty"`
}

// expandLimits expands tf object into dto object
func expandLimits(ctx context.Context, diags diag.Diagnostics, o *tfoLimits) *dtoLimits {
	return &dtoLimits{
		MaxRecentlyQueriedSeriesBlocks:        schemautil.ValueInt64Pointer(o.MaxRecentlyQueriedSeriesBlocks),
		MaxRecentlyQueriedSeriesDiskBytesRead: schemautil.ValueInt64Pointer(o.MaxRecentlyQueriedSeriesDiskBytesRead),
		MaxRecentlyQueriedSeriesLookback:      schemautil.ValueStringPointer(o.MaxRecentlyQueriedSeriesLookback),
		QueryDocs:                             schemautil.ValueInt64Pointer(o.QueryDocs),
		QueryRequireExhaustive:                schemautil.ValueBoolPointer(o.QueryRequireExhaustive),
		QuerySeries:                           schemautil.ValueInt64Pointer(o.QuerySeries),
	}
}

// flattenLimits flattens dto object into tf object
func flattenLimits(ctx context.Context, diags diag.Diagnostics, o *dtoLimits) *tfoLimits {
	return &tfoLimits{
		MaxRecentlyQueriedSeriesBlocks:        types.Int64PointerValue(o.MaxRecentlyQueriedSeriesBlocks),
		MaxRecentlyQueriedSeriesDiskBytesRead: types.Int64PointerValue(o.MaxRecentlyQueriedSeriesDiskBytesRead),
		MaxRecentlyQueriedSeriesLookback:      types.StringPointerValue(o.MaxRecentlyQueriedSeriesLookback),
		QueryDocs:                             types.Int64PointerValue(o.QueryDocs),
		QueryRequireExhaustive:                types.BoolPointerValue(o.QueryRequireExhaustive),
		QuerySeries:                           types.Int64PointerValue(o.QuerySeries),
	}
}

var limitsAttrs = map[string]attr.Type{
	"max_recently_queried_series_blocks":          types.Int64Type,
	"max_recently_queried_series_disk_bytes_read": types.Int64Type,
	"max_recently_queried_series_lookback":        types.StringType,
	"query_docs":                                  types.Int64Type,
	"query_require_exhaustive":                    types.BoolType,
	"query_series":                                types.Int64Type,
}

// tfoM3 M3 specific configuration options
type tfoM3 struct {
	TagOptions types.Set `tfsdk:"tag_options"`
}

// dtoM3 request/response object
type dtoM3 struct {
	TagOptions *dtoTagOptions `groups:"create,update" json:"tag_options,omitempty"`
}

// expandM3 expands tf object into dto object
func expandM3(ctx context.Context, diags diag.Diagnostics, o *tfoM3) *dtoM3 {
	tagOptionsVar := schemautil.ExpandSetBlockNested(ctx, diags, expandTagOptions, o.TagOptions)
	if diags.HasError() {
		return nil
	}
	return &dtoM3{TagOptions: tagOptionsVar}
}

// flattenM3 flattens dto object into tf object
func flattenM3(ctx context.Context, diags diag.Diagnostics, o *dtoM3) *tfoM3 {
	tagOptionsVar := schemautil.FlattenSetBlockNested(ctx, diags, flattenTagOptions, o.TagOptions, tagOptionsAttrs)
	if diags.HasError() {
		return nil
	}
	return &tfoM3{TagOptions: tagOptionsVar}
}

var m3Attrs = map[string]attr.Type{"tag_options": types.SetType{ElemType: types.ObjectType{AttrTypes: tagOptionsAttrs}}}

// tfoTagOptions M3 Tag Options
type tfoTagOptions struct {
	AllowTagNameDuplicates types.Bool `tfsdk:"allow_tag_name_duplicates"`
	AllowTagValueEmpty     types.Bool `tfsdk:"allow_tag_value_empty"`
}

// dtoTagOptions request/response object
type dtoTagOptions struct {
	AllowTagNameDuplicates *bool `groups:"create,update" json:"allow_tag_name_duplicates,omitempty"`
	AllowTagValueEmpty     *bool `groups:"create,update" json:"allow_tag_value_empty,omitempty"`
}

// expandTagOptions expands tf object into dto object
func expandTagOptions(ctx context.Context, diags diag.Diagnostics, o *tfoTagOptions) *dtoTagOptions {
	return &dtoTagOptions{
		AllowTagNameDuplicates: schemautil.ValueBoolPointer(o.AllowTagNameDuplicates),
		AllowTagValueEmpty:     schemautil.ValueBoolPointer(o.AllowTagValueEmpty),
	}
}

// flattenTagOptions flattens dto object into tf object
func flattenTagOptions(ctx context.Context, diags diag.Diagnostics, o *dtoTagOptions) *tfoTagOptions {
	return &tfoTagOptions{
		AllowTagNameDuplicates: types.BoolPointerValue(o.AllowTagNameDuplicates),
		AllowTagValueEmpty:     types.BoolPointerValue(o.AllowTagValueEmpty),
	}
}

var tagOptionsAttrs = map[string]attr.Type{
	"allow_tag_name_duplicates": types.BoolType,
	"allow_tag_value_empty":     types.BoolType,
}

// tfoNamespaces M3 Namespace
type tfoNamespaces struct {
	Name       types.String `tfsdk:"name"`
	Options    types.Set    `tfsdk:"options"`
	Resolution types.String `tfsdk:"resolution"`
	Type       types.String `tfsdk:"type"`
}

// dtoNamespaces request/response object
type dtoNamespaces struct {
	Name       string      `groups:"create,update" json:"name"`
	Options    *dtoOptions `groups:"create,update" json:"options,omitempty"`
	Resolution *string     `groups:"create,update" json:"resolution,omitempty"`
	Type       string      `groups:"create,update" json:"type"`
}

// expandNamespaces expands tf object into dto object
func expandNamespaces(ctx context.Context, diags diag.Diagnostics, o *tfoNamespaces) *dtoNamespaces {
	optionsVar := schemautil.ExpandSetBlockNested(ctx, diags, expandOptions, o.Options)
	if diags.HasError() {
		return nil
	}
	return &dtoNamespaces{
		Name:       o.Name.ValueString(),
		Options:    optionsVar,
		Resolution: schemautil.ValueStringPointer(o.Resolution),
		Type:       o.Type.ValueString(),
	}
}

// flattenNamespaces flattens dto object into tf object
func flattenNamespaces(ctx context.Context, diags diag.Diagnostics, o *dtoNamespaces) *tfoNamespaces {
	optionsVar := schemautil.FlattenSetBlockNested(ctx, diags, flattenOptions, o.Options, optionsAttrs)
	if diags.HasError() {
		return nil
	}
	return &tfoNamespaces{
		Name:       types.StringValue(o.Name),
		Options:    optionsVar,
		Resolution: types.StringPointerValue(o.Resolution),
		Type:       types.StringValue(o.Type),
	}
}

var namespacesAttrs = map[string]attr.Type{
	"name":       types.StringType,
	"options":    types.SetType{ElemType: types.ObjectType{AttrTypes: optionsAttrs}},
	"resolution": types.StringType,
	"type":       types.StringType,
}

// tfoOptions Namespace options
type tfoOptions struct {
	RetentionOptions  types.Set  `tfsdk:"retention_options"`
	SnapshotEnabled   types.Bool `tfsdk:"snapshot_enabled"`
	WritesToCommitlog types.Bool `tfsdk:"writes_to_commitlog"`
}

// dtoOptions request/response object
type dtoOptions struct {
	RetentionOptions  *dtoRetentionOptions `groups:"create,update" json:"retention_options"`
	SnapshotEnabled   *bool                `groups:"create,update" json:"snapshot_enabled,omitempty"`
	WritesToCommitlog *bool                `groups:"create,update" json:"writes_to_commitlog,omitempty"`
}

// expandOptions expands tf object into dto object
func expandOptions(ctx context.Context, diags diag.Diagnostics, o *tfoOptions) *dtoOptions {
	retentionOptionsVar := schemautil.ExpandSetBlockNested(ctx, diags, expandRetentionOptions, o.RetentionOptions)
	if diags.HasError() {
		return nil
	}
	return &dtoOptions{
		RetentionOptions:  retentionOptionsVar,
		SnapshotEnabled:   schemautil.ValueBoolPointer(o.SnapshotEnabled),
		WritesToCommitlog: schemautil.ValueBoolPointer(o.WritesToCommitlog),
	}
}

// flattenOptions flattens dto object into tf object
func flattenOptions(ctx context.Context, diags diag.Diagnostics, o *dtoOptions) *tfoOptions {
	retentionOptionsVar := schemautil.FlattenSetBlockNested(ctx, diags, flattenRetentionOptions, o.RetentionOptions, retentionOptionsAttrs)
	if diags.HasError() {
		return nil
	}
	return &tfoOptions{
		RetentionOptions:  retentionOptionsVar,
		SnapshotEnabled:   types.BoolPointerValue(o.SnapshotEnabled),
		WritesToCommitlog: types.BoolPointerValue(o.WritesToCommitlog),
	}
}

var optionsAttrs = map[string]attr.Type{
	"retention_options":   types.SetType{ElemType: types.ObjectType{AttrTypes: retentionOptionsAttrs}},
	"snapshot_enabled":    types.BoolType,
	"writes_to_commitlog": types.BoolType,
}

// tfoRetentionOptions Retention options
type tfoRetentionOptions struct {
	BlockDataExpiryDuration types.String `tfsdk:"block_data_expiry_duration"`
	BlocksizeDuration       types.String `tfsdk:"blocksize_duration"`
	BufferFutureDuration    types.String `tfsdk:"buffer_future_duration"`
	BufferPastDuration      types.String `tfsdk:"buffer_past_duration"`
	RetentionPeriodDuration types.String `tfsdk:"retention_period_duration"`
}

// dtoRetentionOptions request/response object
type dtoRetentionOptions struct {
	BlockDataExpiryDuration *string `groups:"create,update" json:"block_data_expiry_duration,omitempty"`
	BlocksizeDuration       *string `groups:"create,update" json:"blocksize_duration,omitempty"`
	BufferFutureDuration    *string `groups:"create,update" json:"buffer_future_duration,omitempty"`
	BufferPastDuration      *string `groups:"create,update" json:"buffer_past_duration,omitempty"`
	RetentionPeriodDuration *string `groups:"create,update" json:"retention_period_duration,omitempty"`
}

// expandRetentionOptions expands tf object into dto object
func expandRetentionOptions(ctx context.Context, diags diag.Diagnostics, o *tfoRetentionOptions) *dtoRetentionOptions {
	return &dtoRetentionOptions{
		BlockDataExpiryDuration: schemautil.ValueStringPointer(o.BlockDataExpiryDuration),
		BlocksizeDuration:       schemautil.ValueStringPointer(o.BlocksizeDuration),
		BufferFutureDuration:    schemautil.ValueStringPointer(o.BufferFutureDuration),
		BufferPastDuration:      schemautil.ValueStringPointer(o.BufferPastDuration),
		RetentionPeriodDuration: schemautil.ValueStringPointer(o.RetentionPeriodDuration),
	}
}

// flattenRetentionOptions flattens dto object into tf object
func flattenRetentionOptions(ctx context.Context, diags diag.Diagnostics, o *dtoRetentionOptions) *tfoRetentionOptions {
	return &tfoRetentionOptions{
		BlockDataExpiryDuration: types.StringPointerValue(o.BlockDataExpiryDuration),
		BlocksizeDuration:       types.StringPointerValue(o.BlocksizeDuration),
		BufferFutureDuration:    types.StringPointerValue(o.BufferFutureDuration),
		BufferPastDuration:      types.StringPointerValue(o.BufferPastDuration),
		RetentionPeriodDuration: types.StringPointerValue(o.RetentionPeriodDuration),
	}
}

var retentionOptionsAttrs = map[string]attr.Type{
	"block_data_expiry_duration": types.StringType,
	"blocksize_duration":         types.StringType,
	"buffer_future_duration":     types.StringType,
	"buffer_past_duration":       types.StringType,
	"retention_period_duration":  types.StringType,
}

// tfoPrivateAccess Allow access to selected service ports from private networks
type tfoPrivateAccess struct {
	M3coordinator types.Bool `tfsdk:"m3coordinator"`
}

// dtoPrivateAccess request/response object
type dtoPrivateAccess struct {
	M3coordinator *bool `groups:"create,update" json:"m3coordinator,omitempty"`
}

// expandPrivateAccess expands tf object into dto object
func expandPrivateAccess(ctx context.Context, diags diag.Diagnostics, o *tfoPrivateAccess) *dtoPrivateAccess {
	return &dtoPrivateAccess{M3coordinator: schemautil.ValueBoolPointer(o.M3coordinator)}
}

// flattenPrivateAccess flattens dto object into tf object
func flattenPrivateAccess(ctx context.Context, diags diag.Diagnostics, o *dtoPrivateAccess) *tfoPrivateAccess {
	return &tfoPrivateAccess{M3coordinator: types.BoolPointerValue(o.M3coordinator)}
}

var privateAccessAttrs = map[string]attr.Type{"m3coordinator": types.BoolType}

// tfoPublicAccess Allow access to selected service ports from the public Internet
type tfoPublicAccess struct {
	M3coordinator types.Bool `tfsdk:"m3coordinator"`
}

// dtoPublicAccess request/response object
type dtoPublicAccess struct {
	M3coordinator *bool `groups:"create,update" json:"m3coordinator,omitempty"`
}

// expandPublicAccess expands tf object into dto object
func expandPublicAccess(ctx context.Context, diags diag.Diagnostics, o *tfoPublicAccess) *dtoPublicAccess {
	return &dtoPublicAccess{M3coordinator: schemautil.ValueBoolPointer(o.M3coordinator)}
}

// flattenPublicAccess flattens dto object into tf object
func flattenPublicAccess(ctx context.Context, diags diag.Diagnostics, o *dtoPublicAccess) *tfoPublicAccess {
	return &tfoPublicAccess{M3coordinator: types.BoolPointerValue(o.M3coordinator)}
}

var publicAccessAttrs = map[string]attr.Type{"m3coordinator": types.BoolType}

// tfoRules M3 rules
type tfoRules struct {
	Mapping types.Set `tfsdk:"mapping"`
}

// dtoRules request/response object
type dtoRules struct {
	Mapping []*dtoMapping `groups:"create,update" json:"mapping,omitempty"`
}

// expandRules expands tf object into dto object
func expandRules(ctx context.Context, diags diag.Diagnostics, o *tfoRules) *dtoRules {
	mappingVar := schemautil.ExpandSetNested(ctx, diags, expandMapping, o.Mapping)
	if diags.HasError() {
		return nil
	}
	return &dtoRules{Mapping: mappingVar}
}

// flattenRules flattens dto object into tf object
func flattenRules(ctx context.Context, diags diag.Diagnostics, o *dtoRules) *tfoRules {
	mappingVar := schemautil.FlattenSetNested(ctx, diags, flattenMapping, o.Mapping, mappingAttrs)
	if diags.HasError() {
		return nil
	}
	return &tfoRules{Mapping: mappingVar}
}

var rulesAttrs = map[string]attr.Type{"mapping": types.SetType{ElemType: types.ObjectType{AttrTypes: mappingAttrs}}}

// tfoMapping Mapping rules allow more granular use of aggregation, not simply sending everything to a namespace. If mapping rules exist that target a namespace, only data matching mapping rules will be sent to it and nothing else
type tfoMapping struct {
	Aggregations types.Set    `tfsdk:"aggregations"`
	Drop         types.Bool   `tfsdk:"drop"`
	Filter       types.String `tfsdk:"filter"`
	Name         types.String `tfsdk:"name"`
	Namespaces2  types.Set    `tfsdk:"namespaces"`
	Tags         types.Set    `tfsdk:"tags"`
}

// dtoMapping request/response object
type dtoMapping struct {
	Aggregations []string          `groups:"create,update" json:"aggregations,omitempty"`
	Drop         *bool             `groups:"create,update" json:"drop,omitempty"`
	Filter       string            `groups:"create,update" json:"filter"`
	Name         *string           `groups:"create,update" json:"name,omitempty"`
	Namespaces2  []*dtoNamespaces2 `groups:"create,update" json:"namespaces,omitempty"`
	Tags         []*dtoTags        `groups:"create,update" json:"tags,omitempty"`
}

// expandMapping expands tf object into dto object
func expandMapping(ctx context.Context, diags diag.Diagnostics, o *tfoMapping) *dtoMapping {
	aggregationsVar := schemautil.ExpandSet[string](ctx, diags, o.Aggregations)
	if diags.HasError() {
		return nil
	}
	namespaces2Var := schemautil.ExpandSetNested(ctx, diags, expandNamespaces2, o.Namespaces2)
	if diags.HasError() {
		return nil
	}
	tagsVar := schemautil.ExpandSetNested(ctx, diags, expandTags, o.Tags)
	if diags.HasError() {
		return nil
	}
	return &dtoMapping{
		Aggregations: aggregationsVar,
		Drop:         schemautil.ValueBoolPointer(o.Drop),
		Filter:       o.Filter.ValueString(),
		Name:         schemautil.ValueStringPointer(o.Name),
		Namespaces2:  namespaces2Var,
		Tags:         tagsVar,
	}
}

// flattenMapping flattens dto object into tf object
func flattenMapping(ctx context.Context, diags diag.Diagnostics, o *dtoMapping) *tfoMapping {
	aggregationsVar, d := types.SetValueFrom(ctx, types.StringType, o.Aggregations)
	diags.Append(d...)
	if diags.HasError() {
		return nil
	}
	namespaces2Var := schemautil.FlattenSetNested(ctx, diags, flattenNamespaces2, o.Namespaces2, namespaces2Attrs)
	if diags.HasError() {
		return nil
	}
	tagsVar := schemautil.FlattenSetNested(ctx, diags, flattenTags, o.Tags, tagsAttrs)
	if diags.HasError() {
		return nil
	}
	return &tfoMapping{
		Aggregations: aggregationsVar,
		Drop:         types.BoolPointerValue(o.Drop),
		Filter:       types.StringValue(o.Filter),
		Name:         types.StringPointerValue(o.Name),
		Namespaces2:  namespaces2Var,
		Tags:         tagsVar,
	}
}

var mappingAttrs = map[string]attr.Type{
	"aggregations": types.SetType{ElemType: types.StringType},
	"drop":         types.BoolType,
	"filter":       types.StringType,
	"name":         types.StringType,
	"namespaces":   types.SetType{ElemType: types.ObjectType{AttrTypes: namespaces2Attrs}},
	"tags":         types.SetType{ElemType: types.ObjectType{AttrTypes: tagsAttrs}},
}

// tfoNamespaces2 Filter the namespace by exact match of retention period and resolution
type tfoNamespaces2 struct {
	Resolution types.String `tfsdk:"resolution"`
	Retention  types.String `tfsdk:"retention"`
}

// dtoNamespaces2 request/response object
type dtoNamespaces2 struct {
	Resolution string  `groups:"create,update" json:"resolution"`
	Retention  *string `groups:"create,update" json:"retention,omitempty"`
}

// expandNamespaces2 expands tf object into dto object
func expandNamespaces2(ctx context.Context, diags diag.Diagnostics, o *tfoNamespaces2) *dtoNamespaces2 {
	return &dtoNamespaces2{
		Resolution: o.Resolution.ValueString(),
		Retention:  schemautil.ValueStringPointer(o.Retention),
	}
}

// flattenNamespaces2 flattens dto object into tf object
func flattenNamespaces2(ctx context.Context, diags diag.Diagnostics, o *dtoNamespaces2) *tfoNamespaces2 {
	return &tfoNamespaces2{
		Resolution: types.StringValue(o.Resolution),
		Retention:  types.StringPointerValue(o.Retention),
	}
}

var namespaces2Attrs = map[string]attr.Type{
	"resolution": types.StringType,
	"retention":  types.StringType,
}

// tfoTags Tag to be added
type tfoTags struct {
	Name  types.String `tfsdk:"name"`
	Value types.String `tfsdk:"value"`
}

// dtoTags request/response object
type dtoTags struct {
	Name  string `groups:"create,update" json:"name"`
	Value string `groups:"create,update" json:"value"`
}

// expandTags expands tf object into dto object
func expandTags(ctx context.Context, diags diag.Diagnostics, o *tfoTags) *dtoTags {
	return &dtoTags{
		Name:  o.Name.ValueString(),
		Value: o.Value.ValueString(),
	}
}

// flattenTags flattens dto object into tf object
func flattenTags(ctx context.Context, diags diag.Diagnostics, o *dtoTags) *tfoTags {
	return &tfoTags{
		Name:  types.StringValue(o.Name),
		Value: types.StringValue(o.Value),
	}
}

var tagsAttrs = map[string]attr.Type{
	"name":  types.StringType,
	"value": types.StringType,
}

// Expand public function that converts tf object into dto
func Expand(ctx context.Context, diags diag.Diagnostics, set types.Set) *dtoUserConfig {
	return schemautil.ExpandSetBlockNested[tfoUserConfig, dtoUserConfig](ctx, diags, expandUserConfig, set)
}

// Flatten public function that converts dto into tf object
func Flatten(ctx context.Context, diags diag.Diagnostics, m map[string]any) types.Set {
	o := new(dtoUserConfig)
	err := schemautil.MapToDTO(m, o)
	if err != nil {
		diags.AddError("Failed to marshal map user config to dto", err.Error())
		return types.SetNull(types.ObjectType{AttrTypes: userConfigAttrs})
	}
	return schemautil.FlattenSetBlockNested[dtoUserConfig, tfoUserConfig](ctx, diags, flattenUserConfig, o, userConfigAttrs)
}
