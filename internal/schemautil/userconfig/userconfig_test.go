//go:build userconfig
// +build userconfig

package userconfig

import (
	"fmt"
	"log"
	"reflect"
	"testing"

	"github.com/aiven/go-api-schemas/pkg/dist"
	"github.com/dave/jennifer/jen"
	"github.com/ettle/strcase"
	"golang.org/x/exp/maps"
	"golang.org/x/exp/slices"
)

const (
	typePrimitive      = "primitive"
	typeObject         = "obj"
	typeArray          = "array"
	typeArrayOfObjects = "array-obj"
	typeOneOf          = "one-of"
)

func listOfCorrectTypeResolutions() []string {
	return []string{
		typePrimitive,
		typeObject,
		typeArray,
		typeArrayOfObjects,
		typeOneOf,
	}
}

func listOfPrimitiveTypes() []string {
	return []string{"boolean", "integer", "string", "number"}
}

func getElementType(m map[string]interface{}) string {
	t, ok := m["type"]
	if !ok {
		return "type-is-empty"
	}

	switch reflect.TypeOf(t).Kind() {
	case reflect.Slice, reflect.Array:
		buf := ""
		for _, tt := range t.([]interface{}) {
			tt := tt.(string)
			if tt == "null" {
				continue
			}

			if buf != "" {
				return typeOneOf
			}

			if slices.Contains(listOfPrimitiveTypes(), tt) {
				buf = typePrimitive
			}

			if tt == "array" {
				buf = typeArray

				if i, ok := m["items"]; ok {
					if getElementType(i.(map[string]interface{})) == typeObject {
						buf = typeArrayOfObjects
					}
				}
			}

			if tt == "object" {
				buf = typeObject
			}
		}
		return buf

	case reflect.String:
		tt := t.(string)
		if slices.Contains(listOfPrimitiveTypes(), tt) {
			return typePrimitive
		}

		if tt == "object" {
			return typeObject
		}

		if tt == "array" {
			if i, ok := m["items"]; ok {
				if getElementType(i.(map[string]interface{})) == typeObject {
					return typeArrayOfObjects
				}
			}
			return typeArray
		}
	default:
		return "incorrect-element-type"
	}

	return "type-undefined"
}

func generateToApi(n string, m map[string]interface{}) error {
	f := jen.NewFile("toapi")
	f.HeaderComment("Code generated by internal/schemautil/userconfig/userconfig_test.go; DO NOT EDIT.")

	smk := maps.Keys(m)
	slices.Sort(smk)

	for _, k := range smk {
		kp := strcase.ToGoPascal(k)
		fn := fmt.Sprintf("%s%sToAPIBlueprint", n, kp)
		f.Commentf("%s is a generated function converts TF schema to API format %s %s.", fn, k, n)

		va, ok := m[k].(map[string]interface{})
		if !ok {
			continue
		}

		pa, ok := va["properties"].(map[string]interface{})
		if !ok {
			continue
		}

		f.
			Func().
			Id(fmt.Sprintf("%s%sToAPIBlueprint", n, kp)).Params().
			Id("map[string]interface{}").
			Block(
				jen.Return(
					jen.Map(jen.String()).Interface().Values(generateToApiElements(pa)),
				),
			).
			Line()
	}

	if err := f.Save(fmt.Sprintf("toapi/%s.go", strcase.ToSnake(n)+"s_to_api")); err != nil {
		return err
	}

	return nil
}

func generateToApiElements(m map[string]interface{}) jen.Dict {
	d := make(jen.Dict)
	for k, v := range m {
		if _, ok := v.(map[string]interface{}); !ok {
			continue
		}

		va, ok := m[k].(map[string]interface{})
		if !ok {
			continue
		}

		switch getElementType(va) {
		case typePrimitive, typeArray, typeOneOf:
			d[jen.Lit(k)] = jen.Lit("primitive")
		case typeArrayOfObjects:
			i := va["items"].(map[string]interface{})
			if r := generateToApiElements(i["properties"].(map[string]interface{})); r != nil {
				d[jen.Lit(k)] = jen.Index().Interface().Values(jen.Map(jen.String()).Interface().Values(r))
			}
		case typeObject:
			pa, ok := va["properties"].(map[string]interface{})
			if !ok {
				continue
			}

			d[jen.Lit(k)] = jen.Map(jen.String()).Interface().Values(generateToApiElements(pa))
		default:
			log.Fatalf("unexpected type for `%s`: %s", k, getElementType(va))
		}
	}
	return d
}

// generateSchema is a function that generates Terraform schema via its map representation.
func generateSchema(n string, m map[string]interface{}) error {
	np := fmt.Sprintf("%ss", n)

	f := jen.NewFile("dist")

	f.HeaderComment("Code generated by internal/schemautil/userconfig/userconfig_test.go; DO NOT EDIT.")

	smk := maps.Keys(m)
	slices.Sort(smk)

	for _, k := range smk {
		v := m[k]

		kp := strcase.ToGoPascal(k)

		va, ok := v.(map[string]interface{})
		if !ok {
			continue
		}

		pa, ok := va["properties"].(map[string]interface{})
		if !ok {
			continue
		}

		fn := fmt.Sprintf("%s%s", n, kp)

		f.Commentf("%s is a generated function returning the schema of the %s %s.", fn, k, n)

		pm, err := convertPropertiesToSchemaMap(pa, map[string]struct{}{})
		if err != nil {
			return err
		}

		f.
			Func().
			Id(fn).
			Params().
			Id("*schema.Schema").
			Block(
				jen.Id("s").Op(":=").Map(jen.String()).Op("*").Qual(SchemaPackage, "Schema").Values(pm),

				jen.Line(),

				jen.Return(
					jen.Op("&").Qual(SchemaPackage, "Schema").Values(jen.Dict{
						jen.Id("Type"):        jen.Qual(SchemaPackage, "TypeList"),
						jen.Id("Description"): jen.Lit(fmt.Sprintf("%s user configurable settings", kp)),
						jen.Id("Elem"): jen.Op("&").Qual(SchemaPackage, "Resource").Values(jen.Dict{
							jen.Id("Schema"): jen.Id("s"),
						}),
						jen.Id("Optional"): jen.Lit(true),
						jen.Id("DiffSuppressFunc"): jen.
							Qual(SchemaUtilPackage, "EmptyObjectDiffSuppressFuncSkipArrays").Call(jen.Id("s")),
						jen.Id("MaxItems"): jen.Lit(1),
					}),
				),
			).
			Line()
	}

	if err := f.Save(fmt.Sprintf("dist/%s.go", strcase.ToSnake(np))); err != nil {
		return err
	}

	return nil
}

// TestMain is the entry point for the user config schema generator.
func TestMain(m *testing.M) {
	stm, err := representationToMap(ServiceTypes, dist.ServiceTypes)
	if err != nil {
		panic(err)
	}

	err = generateSchema("ServiceType", stm)
	if err != nil {
		panic(err)
	}

	err = generateToApi("ServiceType", stm)
	if err != nil {
		panic(err)
	}

	itm, err := representationToMap(IntegrationTypes, dist.IntegrationTypes)
	if err != nil {
		panic(err)
	}

	err = generateSchema("IntegrationType", itm)
	if err != nil {
		panic(err)
	}

	ietm, err := representationToMap(IntegrationEndpointTypes, dist.IntegrationEndpointTypes)
	if err != nil {
		panic(err)
	}

	err = generateSchema("IntegrationEndpointType", ietm)
	if err != nil {
		panic(err)
	}
}
