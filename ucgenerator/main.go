package main

import (
	"flag"
	"fmt"
	"go/format"
	"log"
	"os"
	"path/filepath"
	"strconv"
	"strings"

	"github.com/aiven/go-api-schemas/pkg/dist"
	"github.com/dave/jennifer/jen"
	"golang.org/x/exp/slices"
	"golang.org/x/tools/imports"
	"gopkg.in/yaml.v3"
)

const (
	destPath               = "./internal/plugin/service/userconfig/"
	localPrefix            = "github.com/aiven/terraform-provider-aiven"
	importDiag             = "github.com/hashicorp/terraform-plugin-framework/diag"
	importTypes            = "github.com/hashicorp/terraform-plugin-framework/types"
	importAttr             = "github.com/hashicorp/terraform-plugin-framework/attr"
	importSchemautil       = "github.com/aiven/terraform-provider-aiven/internal/schemautil"
	importResourceSchema   = "github.com/hashicorp/terraform-plugin-framework/resource/schema"
	importDatasourceSchema = "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	importListvalidator    = "github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	importValidator        = "github.com/hashicorp/terraform-plugin-framework/schema/validator"
	codeGenerated          = "Code generated by user config generator. DO NOT EDIT."
)

func main() {
	var serviceList, integrationList string
	flag.StringVar(&serviceList, "services", "", "Comma separated service list of names to generate for")
	flag.StringVar(&integrationList, "integrations", "", "Comma separated integrations list of names to generate for")
	flag.Parse()

	if serviceList+integrationList == "" {
		log.Fatal("--service or --integrations must be provided")
	}

	if serviceList != "" {
		err := generate("service", dist.ServiceTypes, strings.Split(serviceList, ","))
		if err != nil {
			log.Fatal(err)
		}
	}

	if integrationList != "" {
		err := generate("integration", dist.IntegrationTypes, strings.Split(integrationList, ","))
		if err != nil {
			log.Fatal(err)
		}
	}
}

func generate(kind string, data []byte, keys []string) error {
	var root map[string]*object

	err := yaml.Unmarshal(data, &root)
	if err != nil {
		return err
	}

	for key, o := range root {
		if !slices.Contains(keys, key) {
			continue
		}

		pkgName := strings.ReplaceAll(key, "_", "")
		o.isRoot = true
		o.init("UserConfig")

		// Generates file
		f := jen.NewFile(pkgName)
		f.HeaderComment(codeGenerated)
		f.ImportAlias(importResourceSchema, "resource")
		f.ImportAlias(importDatasourceSchema, "datasource")
		genAllForObject(f, o)

		// Sorts imports
		imports.LocalPrefix = localPrefix
		b, err := imports.Process("", []byte(f.GoString()), nil)
		if err != nil {
			return err
		}

		// Saves file
		dirPath := filepath.Join(destPath, kind, pkgName)
		err = os.MkdirAll(dirPath, os.ModePerm)
		if err != nil {
			return err
		}

		err = os.WriteFile(filepath.Join(dirPath, key+".go"), b, 0644)
		if err != nil {
			return err
		}

		testFile, err := genTestFile(pkgName, o)
		if err != nil {
			return err
		}

		testFileByte, err := format.Source([]byte(testFile))
		if err != nil {
			return err
		}

		err = os.WriteFile(filepath.Join(dirPath, key+"_test.go"), testFileByte, 0644)
		if err != nil {
			return err
		}
	}
	return nil
}

func genAllForObject(f *jen.File, o *object) {
	genSchema(f, o, "Resource", importResourceSchema)
	genSchema(f, o, "DataSource", importDatasourceSchema)
	genTFObject(f, o)
	genDTOObject(f, o)
	genExpander(f, o)
	genFlattener(f, o)
	genAttrsMap(f, o)

	for _, p := range o.properties {
		if p.isNestedBlock() {
			if p.Type == objectTypeArray {
				genAllForObject(f, p.ArrayItems)
			} else {
				genAllForObject(f, p)
			}
		}
	}

	if !o.isRoot {
		return
	}

	// Exports handy public functions for root object only
	f.Op(`
// Expand public function that converts tf object into dto
func Expand(ctx context.Context, diags *diag.Diagnostics, list types.List) *dtoUserConfig {
	return schemautil.ExpandListBlockNested[tfoUserConfig, dtoUserConfig](ctx, diags, expandUserConfig, list)
}

// Flatten public function that converts dto into tf object
func Flatten(ctx context.Context, diags *diag.Diagnostics, m map[string]any) types.List {
	o := new(dtoUserConfig)
	err := schemautil.MapToDTO(m, o)
	if err != nil {
		diags.AddError("failed to marshal map user config to dto", err.Error())
		return types.ListNull(types.ObjectType{AttrTypes: userConfigAttrs})
	}
	return schemautil.FlattenListBlockNested[dtoUserConfig, tfoUserConfig](ctx, diags, flattenUserConfig, userConfigAttrs, o)
}
`)
}

// genExpander creates function that unwraps TF object into json
func genExpander(f *jen.File, o *object) {
	body := make([]jen.Code, 0)
	props := jen.Dict{}
	for _, p := range o.properties {
		var value *jen.Statement
		switch p.Type {
		case objectTypeObject:
			value = jen.Op(p.varName)
			v := jen.Id(p.varName).Op(":=").Qual(importSchemautil, "ExpandListBlockNested").Types(jen.Id(p.tfoStructName), jen.Id(p.dtoStructName)).Call(
				jen.Id("ctx"),
				jen.Id("diags"),
				jen.Id("expand"+p.camelName),
				jen.Id("o").Dot(p.camelName),
			)
			body = append(body, v, ifErr())
		case objectTypeArray:
			value = jen.Op(p.varName)
			if p.ArrayItems.Type == objectTypeObject {
				// It is a list of objects
				v := jen.Id(p.varName).Op(":=").Qual(importSchemautil, "ExpandListNested").Types(jen.Id(p.tfoStructName), jen.Id(p.dtoStructName)).Call(
					jen.Id("ctx"),
					jen.Id("diags"),
					jen.Id("expand"+p.camelName),
					jen.Id("o").Dot(p.camelName),
				)
				body = append(body, v, ifErr())
			} else {
				// It is a list of scalars
				// We don't want pointer scalars here
				t := strings.ReplaceAll(getDTOType(p.ArrayItems), "*", "")
				v := jen.Id(p.varName).Op(":=").Qual(importSchemautil, "ExpandList").Types(jen.Id(t)).Call(
					jen.Id("ctx"),
					jen.Id("diags"),
					jen.Id("o").Dot(p.camelName),
				)
				body = append(body, v, ifErr())
			}
		default:
			if p.Required {
				value = jen.Id("o").Dot(p.camelName).Dot(getTFTypeToValue(p)).Call()
			} else {
				// Own functions for casting values
				value = jen.Qual(importSchemautil, getTFTypeToValue(p)).Call(jen.Id("o").Dot(p.camelName))
			}
		}

		props[jen.Id(p.camelName)] = value
	}

	// Function body + return statement
	body = append(
		body,
		jen.Return(jen.Id("&"+o.dtoStructName).Values(props)),
	)

	funcName := "expand" + o.camelName
	f.Comment(funcName + " expands tf object into dto object")
	f.Func().Id(funcName).Params(
		jen.Id("ctx").Qual("context", "Context"),
		jen.Id("diags").Op("*").Qual(importDiag, "Diagnostics"),
		jen.Id("o").Op("*"+o.tfoStructName),
	).Id("*" + o.dtoStructName).Block(body...)
}

// genFlattener creates function that unwraps json into TF object
func genFlattener(f *jen.File, o *object) {
	body := make([]jen.Code, 0)
	props := jen.Dict{}
	for _, p := range o.properties {
		var value *jen.Statement
		switch p.Type {
		case objectTypeObject:
			value = jen.Op(p.varName)
			v := jen.Id(p.varName).Op(":=").Qual(importSchemautil, "FlattenListBlockNested").Types(jen.Id(p.dtoStructName), jen.Id(p.tfoStructName)).Call(
				jen.Id("ctx"),
				jen.Id("diags"),
				jen.Id("flatten"+p.camelName),
				jen.Id(p.attrsName),
				jen.Id("o").Dot(p.camelName),
			)
			body = append(body, v, ifErr())
		case objectTypeArray:
			value = jen.Op(p.varName)
			if p.ArrayItems.Type == objectTypeObject {
				// It is a list of objects
				v := jen.Id(p.varName).Op(":=").Qual(importSchemautil, "FlattenListNested").Types(jen.Id(p.dtoStructName), jen.Id(p.tfoStructName)).Call(
					jen.Id("ctx"),
					jen.Id("diags"),
					jen.Id("flatten"+p.camelName),
					jen.Id(p.attrsName),
					jen.Id("o").Dot(p.camelName),
				)
				body = append(body, v, ifErr())
			} else {
				//It is a list of scalars
				v := jen.List(jen.Id(p.varName), jen.Id("d")).Op(":=").Qual(importTypes, "ListValueFrom").Call(
					jen.Id("ctx"),
					jen.Qual(importTypes, getTFType(p.ArrayItems)+"Type"),
					jen.Id("o").Dot(p.camelName),
				)
				body = append(
					body,
					v,
					jen.Id("diags").Dot("Append").Call(jen.Id("d").Op("...")),
					ifErr(),
				)
			}
		default:
			value = jen.Qual(importTypes, getTFTypeFromValue(p)).Call(jen.Id("o").Dot(p.camelName))
		}

		if value == nil {
			continue
		}

		props[jen.Id(p.camelName)] = value
	}

	// Function body + return statement
	body = append(
		body,
		jen.Return(jen.Id("&"+o.tfoStructName).Values(props)),
	)

	funcName := "flatten" + o.camelName
	f.Comment(funcName + " flattens dto object into tf object")
	f.Func().Id(funcName).Params(
		jen.Id("ctx").Qual("context", "Context"),
		jen.Id("diags").Op("*").Qual(importDiag, "Diagnostics"),
		jen.Id("o").Op("*"+o.dtoStructName),
	).Id("*" + o.tfoStructName).Block(body...)
}

// genAttrsMap creates attributes map for Flatten functions to "unwrap" response json into TF object
func genAttrsMap(f *jen.File, o *object) {
	values := jen.Dict{}
	for _, p := range o.properties {
		key := jen.Lit(p.tfName)
		switch p.Type {
		case objectTypeArray, objectTypeObject:
			var v jen.Code
			if p.isNestedBlock() {
				v = jen.Qual(importTypes, "ObjectType").Values(jen.Dict{
					jen.Id("AttrTypes"): jen.Id(p.attrsName),
				})
			} else {
				v = jen.Qual(importTypes, getTFType(p.ArrayItems)+"Type")
			}
			values[key] = jen.Qual(importTypes, "ListType").Values(jen.Dict{jen.Id("ElemType"): v})
		default:
			values[key] = jen.Qual(importTypes, getTFType(p)+"Type")
		}
	}
	f.Var().Id(o.attrsName).Op("=").Map(jen.String()).Qual(importAttr, "Type").Values(values)
}

// genTFObject creates TF object (for plan)
func genTFObject(f *jen.File, o *object) {
	fields := make([]jen.Code, 0)
	for _, p := range o.properties {
		fields = append(fields, jen.Id(p.camelName).Qual(importTypes, getTFType(p)).Tag(map[string]string{"tfsdk": p.tfName}))
	}
	f.Comment(fmt.Sprintf("%s %s", o.tfoStructName, getDescription(o)))
	f.Type().Id(o.tfoStructName).Struct(fields...)
}

// genDTOObject creates DTO object to send over HTTP
func genDTOObject(f *jen.File, o *object) {
	fields := make([]jen.Code, 0)
	for _, p := range o.properties {
		tags := map[string]string{"json": p.jsonName, "groups": "create"}
		if !p.Required {
			tags["json"] += ",omitempty"
		}
		if !p.CreateOnly {
			tags["groups"] += ",update"
		}
		fields = append(fields, jen.Id(p.camelName).Id(getDTOType(p)).Tag(tags))
	}
	f.Comment(o.dtoStructName + " request/response object")
	f.Type().Id(o.dtoStructName).Struct(fields...)
}

// genSchema generates TF schema. For root object only, i.e. RedisUserConfig
func genSchema(f *jen.File, o *object, name, pkg string) {
	if !o.isRoot {
		return
	}

	funcName := fmt.Sprintf("New%sSchema", name)
	f.Comment(fmt.Sprintf("%s returns %s schema", funcName, strings.ToLower(name)))
	f.Func().Id(funcName).Params().Qual(pkg, "ListNestedBlock").Block(
		jen.Return(getSchemaAttributes(o, pkg)),
	)
}

func getSchemaAttributes(o *object, pkg string) jen.Code {
	isResource := pkg == importResourceSchema
	blocks := jen.Dict{}
	attribs := jen.Dict{}

	// Array properties are its item properties
	properties := o.properties
	if o.Type == objectTypeArray {
		properties = o.ArrayItems.properties
	}

	for _, p := range properties {
		key := jen.Lit(p.tfName)
		if p.isNestedBlock() {
			blocks[key] = getSchemaAttributes(p, pkg)
		} else {
			// For scalars
			var value *jen.Statement
			switch p.Type {
			case objectTypeObject:
				// Schemaless map
				panic("schemaless objects are not supported")
			case objectTypeArray:
				value = jen.Qual(importTypes, getTFType(p.ArrayItems)+"Type")
			}

			values := getSchemaAttributeValues(p, isResource)
			values[jen.Id("ElementType")] = value
			attribs[jen.Lit(p.tfName)] = jen.Qual(pkg, getTFType(p)+"Attribute").Values(values)
		}
	}

	nested := jen.Dict{}
	if len(blocks) > 0 {
		nested[jen.Id("Blocks")] = jen.Map(jen.String()).Qual(pkg, "Block").Values(blocks)
	}

	if len(attribs) > 0 {
		nested[jen.Id("Attributes")] = jen.Map(jen.String()).Qual(pkg, "Attribute").Values(attribs)
	}

	values := getSchemaAttributeValues(o, isResource)
	values[jen.Id("NestedObject")] = jen.Qual(pkg, "NestedBlockObject").Values(nested)
	return jen.Qual(pkg, "ListNestedBlock").Values(values)
}

func getSchemaAttributeValues(o *object, isResource bool) jen.Dict {
	a := jen.Dict{}

	if d := getDescription(o); d != "" {
		a[jen.Id("Description")] = jen.Lit(d)
	}

	if o.IsDeprecated {
		a[jen.Id("DeprecationMessage")] = jen.Lit(fmt.Sprintf("%q is deprecated", o.tfName))
	}

	validators := make([]jen.Code, 0)
	if o.MinItems != nil {
		validators = append(validators, valSizeAtLeast(*o.MinItems))
	}

	if o.MaxItems != nil {
		validators = append(validators, valSizeAtMost(*o.MaxItems))
	}

	if !o.isNestedBlock() {
		if !isResource {
			a[jen.Id("Computed")] = jen.True()
		} else {
			if o.Required {
				a[jen.Id("Required")] = jen.True()
			} else {
				a[jen.Id("Computed")] = jen.True()
				a[jen.Id("Optional")] = jen.True()

				if o.Default != nil {
					a[jen.Id("Default")] = getStaticDefault(o)
				}
			}
		}
	}

	if len(validators) > 0 {
		a[jen.Id("Validators")] = valValidatorList(validators...)
	}

	return a
}

// getTFType matches generator types into plugin types
func getTFType(o *object) string {
	switch o.Type {
	case objectTypeObject:
		if o.isNestedBlock() {
			return "List"
		}
		return "Map"
	case objectTypeArray:
		return "List"
	case objectTypeString:
		return "String"
	case objectTypeBoolean:
		return "Bool"
	case objectTypeInteger:
		return "Int64"
	case objectTypeNumber:
		return "Float64"
	}
	panic(fmt.Sprintf("Unknown type for %q", o.jsonName))
}

func getTFTypeToValue(o *object) string {
	v := getTFType(o)
	if !o.Required {
		return fmt.Sprintf("Value%sPointer", v)
	}
	return "Value" + v
}

func getTFTypeFromValue(o *object) string {
	v := getTFType(o)
	if !o.Required {
		return v + "PointerValue"
	}
	return v + "Value"
}

func getDTOType(o *object) string {
	optional := "*"
	if o.Required {
		optional = ""
	}

	switch o.Type {
	case objectTypeObject:
		return "*" + o.dtoStructName
	case objectTypeArray:
		t := "[]" + getDTOType(o.ArrayItems)
		if o.ArrayItems.Type == objectTypeObject {
			return t
		}
		// We don't want pointer scalars in slice
		return strings.ReplaceAll(t, "*", "")
	case objectTypeString:
		return optional + "string"
	case objectTypeBoolean:
		return optional + "bool"
	case objectTypeInteger:
		return optional + "int64"
	case objectTypeNumber:
		return optional + "float64"
	}
	panic(fmt.Sprintf("Unknown type for %q", o.jsonName))
}

// getStaticDefault returns "default" value for given field
func getStaticDefault(o *object) *jen.Statement {
	var v *jen.Statement
	switch o.Type {
	case objectTypeString:
		v = jen.Lit(o.Default.(string))
	case objectTypeInteger:
		d, err := strconv.Atoi(o.Default.(string))
		if err != nil {
			return nil
		}
		v = jen.Lit(d)
	case objectTypeNumber:
		v = jen.Lit(o.Default.(float64))
	case objectTypeBoolean:
		v = jen.Lit(o.Default.(bool))
	default:
		return nil
	}
	d := getTFType(o)
	i := fmt.Sprintf("%s/%sdefault", importResourceSchema, strings.ToLower(d))
	return jen.Qual(i, "Static"+d).Call(v)
}

func getDescription(o *object) string {
	desc := make([]string, 0)
	d := o.Description
	if len(d) < len(o.Title) {
		d = o.Title
	}

	if d != "" {
		desc = append(desc, addDot(d))
	}

	if o.Default != nil && o.Type != objectTypeArray {
		desc = append(desc, fmt.Sprintf("The default value is `%v`.", o.Default))
	}

	// Trims dot from description, so it doesn't look weird with link to nested schema
	// Example: Databases to expose[dot] (see [below for nested schema]...)
	if len(desc) == 1 && o.isNestedBlock() {
		return strings.Trim(desc[0], ".")
	}

	return strings.Join(desc, " ")
}

func addDot(s string) string {
	if s != "" {
		switch s[len(s)-1:] {
		case ".", "!", "?":
		default:
			s += "."
		}
	}
	return s
}

func getValidator(name string, v any) *jen.Statement {
	return jen.Qual(importListvalidator, name).Call(jen.Lit(v))
}

func valSizeAtLeast(n int) *jen.Statement {
	return getValidator("SizeAtLeast", n)
}

func valSizeAtMost(n int) *jen.Statement {
	return getValidator("SizeAtMost", n)
}

func valValidatorList(c ...jen.Code) *jen.Statement {
	return jen.Index().Qual(importValidator, "List").Values(c...)
}

func ifErr() *jen.Statement {
	return jen.If(jen.Id("diags").Dot("HasError").Call()).Block(jen.Return(jen.Nil()))
}

func toPtr[T any](v T) *T {
	return &v
}
