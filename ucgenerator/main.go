package main

import (
	"flag"
	"fmt"
	"go/format"
	"log"
	"os"
	"path/filepath"
	"strconv"
	"strings"

	"github.com/aiven/go-api-schemas/pkg/dist"
	"github.com/dave/jennifer/jen"
	"github.com/stoewer/go-strcase"
	"golang.org/x/exp/slices"
	"golang.org/x/tools/imports"
	"gopkg.in/yaml.v3"
)

const (
	destPath               = "./internal/plugin/service/userconfig/"
	localPrefix            = "github.com/aiven/terraform-provider-aiven"
	importDiag             = "github.com/hashicorp/terraform-plugin-framework/diag"
	importTypes            = "github.com/hashicorp/terraform-plugin-framework/types"
	importAttr             = "github.com/hashicorp/terraform-plugin-framework/attr"
	importSchemautil       = "github.com/aiven/terraform-provider-aiven/internal/schemautil"
	importResourceSchema   = "github.com/hashicorp/terraform-plugin-framework/resource/schema"
	importDatasourceSchema = "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	importSetValidator     = "github.com/hashicorp/terraform-plugin-framework-validators/setvalidator"
	importValidator        = "github.com/hashicorp/terraform-plugin-framework/schema/validator"
	codeGenerated          = "Code generated by user config generator. DO NOT EDIT."
)

func main() {
	var serviceList, integrationList string
	flag.StringVar(&serviceList, "services", "", "Comma separated service list of names to generate for")
	flag.StringVar(&integrationList, "integrations", "", "Comma separated integrations list of names to generate for")
	flag.Parse()

	if serviceList+integrationList == "" {
		log.Fatal("--service or --integrations must be provided")
	}

	if serviceList != "" {
		err := generate("service", dist.ServiceTypes, strings.Split(serviceList, ","))
		if err != nil {
			log.Fatal(err)
		}
	}

	if integrationList != "" {
		err := generate("integration", dist.IntegrationTypes, strings.Split(integrationList, ","))
		if err != nil {
			log.Fatal(err)
		}
	}
}

func generate(kind string, data []byte, keys []string) error {
	var root map[string]*object

	err := yaml.Unmarshal(data, &root)
	if err != nil {
		return err
	}

	for key, o := range root {
		if !slices.Contains(keys, key) {
			continue
		}

		pkgName := strings.ReplaceAll(key, "_", "")
		o.isRoot = true
		o.init("UserConfig", make(map[string]int))
		if o.Description == "" {
			o.Description = strcase.UpperCamelCase(key) + " user configurable settings"
		}

		// Generates file
		f := jen.NewFile(pkgName)
		f.HeaderComment(codeGenerated)
		f.ImportAlias(importResourceSchema, "resource")
		f.ImportAlias(importDatasourceSchema, "datasource")
		genAllForObject(f, o)

		// Sorts imports
		imports.LocalPrefix = localPrefix
		b, err := imports.Process("", []byte(f.GoString()), nil)
		if err != nil {
			return err
		}

		// Saves file
		dirPath := filepath.Join(destPath, kind, pkgName)
		err = os.MkdirAll(dirPath, os.ModePerm)
		if err != nil {
			return err
		}

		err = os.WriteFile(filepath.Join(dirPath, key+".go"), b, 0644)
		if err != nil {
			return err
		}

		testFile, err := genTestFile(pkgName, o)
		if err != nil {
			return err
		}

		testFileByte, err := format.Source([]byte(testFile))
		if err != nil {
			return err
		}

		err = os.WriteFile(filepath.Join(dirPath, key+"_test.go"), testFileByte, 0644)
		if err != nil {
			return err
		}
	}
	return nil
}

func genAllForObject(f *jen.File, o *object) {
	genSchema(f, o, "Resource", importResourceSchema)
	genSchema(f, o, "DataSource", importDatasourceSchema)
	genTFObject(f, o)
	genDTOObject(f, o)
	genExpander(f, o)
	genFlattener(f, o)
	genAttrsMap(f, o)

	for _, p := range o.ListProperties() {
		if p.isNestedBlock() {
			if p.isArray() {
				genAllForObject(f, p.ArrayItems)
			} else {
				genAllForObject(f, p)
			}
		}
	}

	if !o.isRoot {
		return
	}

	// Exports handy public functions for root object only
	f.Op(`
// Expand public function that converts tf object into dto
func Expand(ctx context.Context, diags diag.Diagnostics, set types.Set) *dtoUserConfig {
	return schemautil.ExpandSetBlockNested[tfoUserConfig, dtoUserConfig](ctx, diags, expandUserConfig, set)
}

// Flatten public function that converts dto into tf object
func Flatten(ctx context.Context, diags diag.Diagnostics, m map[string]any) types.Set {
	o := new(dtoUserConfig)
	err := schemautil.MapToDTO(m, o)
	if err != nil {
		diags.AddError("Failed to marshal map user config to dto", err.Error())
		return types.SetNull(types.ObjectType{AttrTypes: userConfigAttrs})
	}
	return schemautil.FlattenSetBlockNested[dtoUserConfig, tfoUserConfig](ctx, diags, flattenUserConfig, o, userConfigAttrs)
}
`)
}

// genExpander creates a function that unwraps TF object into json
func genExpander(f *jen.File, o *object) {
	body := make([]jen.Code, 0)
	props := jen.Dict{}

	for _, p := range o.ListProperties() {
		value := jen.Op(p.varName)
		switch {
		case p.isNestedBlock():
			body = append(body, varConverter(p, "expand"), ifErr())
		case p.isArray():
			// It is a list of scalars
			// We don't want pointer scalars here
			t := strings.ReplaceAll(getDTOType(p.ArrayItems), "*", "")
			v := jen.Id(p.varName).Op(":=").Qual(importSchemautil, "ExpandSet").Types(jen.Id(t)).Call(
				jen.Id("ctx"),
				jen.Id("diags"),
				jen.Id("o").Dot(p.camelName),
			)
			body = append(body, v, ifErr())
		default:
			if p.Required {
				value = jen.Id("o").Dot(p.camelName).Dot(getTFTypeToValue(p)).Call()
			} else {
				// Own functions for casting values
				value = jen.Qual(importSchemautil, getTFTypeToValue(p)).Call(jen.Id("o").Dot(p.camelName))
			}
		}

		props[jen.Id(p.camelName)] = value
	}

	// Function body + return statement
	body = append(body, jen.Return(jen.Id("&"+o.dtoStructName).Values(props)))

	funcName := "expand" + o.camelName
	f.Comment(funcName + " expands tf object into dto object")
	f.Func().Id(funcName).Params(
		jen.Id("ctx").Qual("context", "Context"),
		jen.Id("diags").Qual(importDiag, "Diagnostics"),
		jen.Id("o").Op("*"+o.tfoStructName),
	).Id("*" + o.dtoStructName).Block(body...)
}

// genFlattener creates a function that unwraps json into TF object
func genFlattener(f *jen.File, o *object) {
	body := make([]jen.Code, 0)
	props := jen.Dict{}

	for _, p := range o.ListProperties() {
		value := jen.Op(p.varName)
		switch {
		case p.isNestedBlock():
			body = append(body, varConverter(p, "flatten"), ifErr())
		case p.isArray():
			//It is a list of scalars
			v := jen.List(jen.Id(p.varName), jen.Id("d")).Op(":=").Qual(importTypes, "SetValueFrom").Call(
				jen.Id("ctx"),
				jen.Qual(importTypes, getTFType(p.ArrayItems)+"Type"),
				jen.Id("o").Dot(p.camelName),
			)
			body = append(
				body,
				v,
				jen.Id("diags").Dot("Append").Call(jen.Id("d").Op("...")),
				ifErr(),
			)
		default:
			value = jen.Qual(importTypes, getTFTypeFromValue(p)).Call(jen.Id("o").Dot(p.camelName))
		}

		props[jen.Id(p.camelName)] = value
	}

	// Function body + return statement
	body = append(body, jen.Return(jen.Id("&"+o.tfoStructName).Values(props)))

	funcName := "flatten" + o.camelName
	f.Comment(funcName + " flattens dto object into tf object")
	f.Func().Id(funcName).Params(
		jen.Id("ctx").Qual("context", "Context"),
		jen.Id("diags").Qual(importDiag, "Diagnostics"),
		jen.Id("o").Op("*"+o.dtoStructName),
	).Id("*" + o.tfoStructName).Block(body...)
}

// varConverter makes a string like:
// publicAccessVar := schemautil.FlattenSetBlockNested(ctx, diags, flattenPublicAccess, o.PublicAccess, publicAccessAttrs)
func varConverter(o *object, action string) *jen.Statement {
	args := []jen.Code{
		jen.Id("ctx"),
		jen.Id("diags"),
		jen.Id(action + o.camelName),
		jen.Id("o").Dot(o.camelName),
	}

	var f string
	switch {
	case action == "expand":
		f = "ExpandSetNested"
		if o.isObject() {
			f = "ExpandSetBlockNested"
		}
	default:
		f = "FlattenSetNested"
		args = append(args, jen.Id(o.attrsName))
		if o.isObject() {
			f = "FlattenSetBlockNested"
		}
	}

	return jen.Id(o.varName).Op(":=").Qual(importSchemautil, f).Call(args...)
}

// genAttrsMap creates an attribute map for Flatten functions to "unwrap" response json into TF object
func genAttrsMap(f *jen.File, o *object) {
	values := jen.Dict{}
	for _, p := range o.ListProperties() {
		key := jen.Lit(p.tfName)
		if p.isScalar() {
			values[key] = jen.Qual(importTypes, getTFType(p)+"Type")
			continue
		}

		var v jen.Code
		if p.isNestedBlock() {
			v = jen.Qual(importTypes, "ObjectType").Values(jen.Dict{
				jen.Id("AttrTypes"): jen.Id(p.attrsName),
			})
		} else {
			v = jen.Qual(importTypes, getTFType(p.ArrayItems)+"Type")
		}
		values[key] = jen.Qual(importTypes, "SetType").Values(jen.Dict{jen.Id("ElemType"): v})
	}
	f.Var().Id(o.attrsName).Op("=").Map(jen.String()).Qual(importAttr, "Type").Values(values)
}

// genTFObject creates a TF object (for plan)
func genTFObject(f *jen.File, o *object) {
	fields := make([]jen.Code, 0)
	for _, p := range o.ListProperties() {
		fields = append(fields, jen.Id(p.camelName).Qual(importTypes, getTFType(p)).Tag(map[string]string{"tfsdk": p.tfName}))
	}
	f.Comment(fmt.Sprintf("%s %s", o.tfoStructName, getDescription(o)))
	f.Type().Id(o.tfoStructName).Struct(fields...)
}

// genDTOObject creates a DTO object to send over HTTP
func genDTOObject(f *jen.File, o *object) {
	fields := make([]jen.Code, 0)
	for _, p := range o.ListProperties() {
		tags := map[string]string{"json": p.jsonName, "groups": "create"}
		if !p.Required {
			tags["json"] += ",omitempty"
		}
		if !p.CreateOnly {
			tags["groups"] += ",update"
		}
		fields = append(fields, jen.Id(p.camelName).Id(getDTOType(p)).Tag(tags))
	}
	f.Comment(o.dtoStructName + " request/response object")
	f.Type().Id(o.dtoStructName).Struct(fields...)

	if o.jsonName == "ip_filter" {
		f.Add(jen.Op(strings.ReplaceAll(ipFilterUnmarshal, "|", "`")))
	}
}

// genSchema generates TF schema. For root object only, i.e. RedisUserConfig
func genSchema(f *jen.File, o *object, name, pkg string) {
	if !o.isRoot {
		return
	}

	funcName := fmt.Sprintf("New%sSchema", name)
	f.Comment(fmt.Sprintf("%s returns %s schema", funcName, strings.ToLower(name)))
	f.Func().Id(funcName).Params().Qual(pkg, "SetNestedBlock").Block(
		jen.Return(getSchemaAttributes(o, pkg)),
	)
}

func getSchemaAttributes(o *object, pkg string) jen.Code {
	isResource := pkg == importResourceSchema
	blocks := jen.Dict{}
	attribs := jen.Dict{}

	for _, p := range o.ListProperties() {
		key := jen.Lit(p.tfName)
		if p.isNestedBlock() {
			blocks[key] = getSchemaAttributes(p, pkg)
		} else {
			// For scalars
			var value *jen.Statement
			switch p.Type {
			case objectTypeObject:
				// Schemaless map
				panic("schemaless objects are not supported")
			case objectTypeArray:
				value = jen.Qual(importTypes, getTFType(p.ArrayItems)+"Type")
			}

			values := getSchemaAttributeValues(p, isResource)
			if value != nil {
				values[jen.Id("ElementType")] = value
			}
			attribs[jen.Lit(p.tfName)] = jen.Qual(pkg, getTFType(p)+"Attribute").Values(values)
		}
	}

	nested := jen.Dict{}
	if len(blocks) > 0 {
		nested[jen.Id("Blocks")] = jen.Map(jen.String()).Qual(pkg, "Block").Values(blocks)
	}

	if len(attribs) > 0 {
		nested[jen.Id("Attributes")] = jen.Map(jen.String()).Qual(pkg, "Attribute").Values(attribs)
	}

	values := getSchemaAttributeValues(o, isResource)
	values[jen.Id("NestedObject")] = jen.Qual(pkg, "NestedBlockObject").Values(nested)
	return jen.Qual(pkg, "SetNestedBlock").Values(values)
}

func getSchemaAttributeValues(o *object, isResource bool) jen.Dict {
	a := jen.Dict{}

	if d := getDescription(o); d != "" {
		a[jen.Id("Description")] = jen.Lit(d)
	}

	if o.IsDeprecated {
		a[jen.Id("DeprecationMessage")] = jen.Lit(fmt.Sprintf("%q is deprecated", o.tfName))
	}

	validators := make([]jen.Code, 0)
	if o.MinItems != nil {
		validators = append(validators, valSizeAtLeast(*o.MinItems))
	}

	if o.MaxItems != nil {
		validators = append(validators, valSizeAtMost(*o.MaxItems))
	}

	if !o.isNestedBlock() {
		if !isResource {
			a[jen.Id("Computed")] = jen.True()
		} else {
			if o.Required {
				a[jen.Id("Required")] = jen.True()
			} else {
				a[jen.Id("Computed")] = jen.True()
				a[jen.Id("Optional")] = jen.True()

				if o.Default != nil {
					a[jen.Id("Default")] = getStaticDefault(o)
				}
			}
		}
	}

	if len(validators) > 0 {
		a[jen.Id("Validators")] = valValidatorSet(validators...)
	}

	return a
}

// getTFType matches generator types into plugin types
func getTFType(o *object) string {
	switch o.Type {
	case objectTypeObject:
		if o.isNestedBlock() {
			return "Set"
		}
		return "Map"
	case objectTypeArray:
		return "Set"
	case objectTypeString:
		return "String"
	case objectTypeBoolean:
		return "Bool"
	case objectTypeInteger:
		return "Int64"
	case objectTypeNumber:
		return "Float64"
	}
	panic(fmt.Sprintf("Unknown type for %q, original type is %v", o.jsonName, o.OrigType))
}

func getTFTypeToValue(o *object) string {
	v := getTFType(o)
	if !o.Required {
		return fmt.Sprintf("Value%sPointer", v)
	}
	return "Value" + v
}

func getTFTypeFromValue(o *object) string {
	v := getTFType(o)
	if !o.Required {
		return v + "PointerValue"
	}
	return v + "Value"
}

func getDTOType(o *object) string {
	optional := "*"
	if o.Required {
		optional = ""
	}

	switch o.Type {
	case objectTypeObject:
		return "*" + o.dtoStructName
	case objectTypeArray:
		t := "[]" + getDTOType(o.ArrayItems)
		if o.ArrayItems.isObject() {
			return t
		}
		// We don't want pointer scalars in slice
		return strings.ReplaceAll(t, "*", "")
	case objectTypeString:
		return optional + "string"
	case objectTypeBoolean:
		return optional + "bool"
	case objectTypeInteger:
		return optional + "int64"
	case objectTypeNumber:
		return optional + "float64"
	}
	panic(fmt.Sprintf("Unknown type for %q", o.jsonName))
}

// getStaticDefault returns "default" value for given field
func getStaticDefault(o *object) *jen.Statement {
	var v *jen.Statement
	switch o.Type {
	case objectTypeString:
		v = jen.Lit(o.Default.(string))
	case objectTypeInteger:
		d, err := strconv.Atoi(o.Default.(string))
		if err != nil {
			return nil
		}
		v = jen.Lit(d)
	case objectTypeNumber:
		v = jen.Lit(o.Default.(float64))
	case objectTypeBoolean:
		v = jen.Lit(o.Default.(bool))
	default:
		return nil
	}
	d := getTFType(o)
	i := fmt.Sprintf("%s/%sdefault", importResourceSchema, strings.ToLower(d))
	return jen.Qual(i, "Static"+d).Call(v)
}

func getDescription(o *object) string {
	desc := make([]string, 0)
	d := o.Description
	if len(d) < len(o.Title) {
		d = o.Title
	}

	// Comes from the schema, quite confusing
	d = strings.TrimSuffix(d, "The default value is `map[]`.")
	if d != "" {
		desc = append(desc, addDot(d))
	}

	if o.isScalar() && o.Default != nil {
		desc = append(desc, fmt.Sprintf("The default value is `%v`.", o.Default))
	}

	// Trims dot from description, so it doesn't look weird with link to nested schema
	// Example: Databases to expose[dot] (see [below for nested schema]...)
	if len(desc) == 1 && o.isNestedBlock() {
		return strings.Trim(desc[0], ".")
	}

	return strings.Join(desc, " ")
}

func addDot(s string) string {
	if s != "" {
		switch s[len(s)-1:] {
		case ".", "!", "?":
		default:
			s += "."
		}
	}
	return s
}

func getValidator(name string, v any) *jen.Statement {
	return jen.Qual(importSetValidator, name).Call(jen.Lit(v))
}

func valSizeAtLeast(n int) *jen.Statement {
	return getValidator("SizeAtLeast", n)
}

func valSizeAtMost(n int) *jen.Statement {
	return getValidator("SizeAtMost", n)
}

func valValidatorSet(c ...jen.Code) *jen.Statement {
	return jen.Index().Qual(importValidator, "Set").Values(c...)
}

func ifErr() *jen.Statement {
	return jen.If(jen.Id("diags").Dot("HasError").Call()).Block(jen.Return(jen.Nil()))
}

func toPtr[T any](v T) *T {
	return &v
}

const ipFilterUnmarshal = `
func (d *dtoIpFilter) UnmarshalJSON(data []byte) error {
	var s string
	err := json.Unmarshal(data, &s)
	if err == nil {
		d.Network = s
		return nil
	}

	type obj dtoIpFilter
	o := &struct {
		Description *string |groups:"create,update" json:"description,omitempty"|
		Network     string  |groups:"create,update" json:"network"|
	}{}
	err = json.Unmarshal(data, o)
	if err != nil {
		return err 
	}
	
	d.Description = o.Description
	d.Network = o.Network
	return nil
}
`
